This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.dockerignore
.env.example
.gitignore
check-data-structure.js
check-dependencies.js
config/default.json
debug.js
diagnose.js
docker-bot.bat
docker-bot.sh
docker-compose.yml
Dockerfile
health-check.js
INSTALL.md
memory-bank/.clinerules
memory-bank/activeContext.md
memory-bank/productContext.md
memory-bank/progress.md
memory-bank/projectbrief.md
memory-bank/systemPatterns.md
memory-bank/techContext.md
package.json
PERFORMANCE-OPTIMIZATIONS.md
README-DOCKER.md
README-LLM-UPDATES.md
README-UPDATED.md
README.md
src/commands/end.js
src/commands/help.js
src/commands/mode.js
src/commands/model.js
src/commands/start.js
src/commands/stats.js
src/events/messageCreate.js
src/events/ready.js
src/index.js
src/models/anthropicModel.js
src/models/googleModel.js
src/models/openaiModel.js
src/services/translationService.js
src/utils/serverConfig.js
src/utils/translationMemory.js
src/utils/webhookManager.js
test-api-keys.js
test-llm-detection.js
test.js
TROUBLESHOOTING.md

================================================================
Files
================================================================

================
File: .dockerignore
================
# Version control
.git
.gitignore

# Environment variables
.env
.env.*
!.env.example

# Dependencies
node_modules
npm-debug.log

# Local data and logs
data/*
logs/*

# Build artifacts
dist
build

# Editor files
.vscode
.idea
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Docker files (no need to include in the build)
Dockerfile
docker-compose.yml
.dockerignore

# Debug files
debug.js
diagnose.js
test*.js

================
File: .env.example
================
# Discord Bot Token (Required)
# Get this from the Discord Developer Portal: https://discord.com/developers/applications
DISCORD_TOKEN=your_discord_bot_token_here

# OpenAI API Key
# Get this from: https://platform.openai.com/api-keys
OPENAI_API_KEY=your_openai_api_key_here

# Anthropic API Key (for Claude models)
# Get this from: https://console.anthropic.com/
ANTHROPIC_API_KEY=your_anthropic_api_key_here

# Google API Key (for Gemini models)
# Get this from: https://makersuite.google.com/app/apikey
GOOGLE_API_KEY=your_google_api_key_here

# Note: Copy this file to .env and replace the placeholder values with your actual API keys
# The .env file should not be committed to version control

================
File: .gitignore
================
# Environment variables
.env

# Dependency directories
node_modules/

# Optional npm cache directory
.npm

# Translation memory and server configurations
data/translations.json
data/servers/

# Logs
logs
*.log
npm-debug.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# OS specific files
.DS_Store
Thumbs.db

================
File: check-data-structure.js
================
// Directory structure and permissions diagnostic script
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the current file's directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

console.log('==== Discord Translator Bot Data Structure Check ====');

// Define key directories
const dataDir = path.join(__dirname, 'data');
const serversDir = path.join(dataDir, 'servers');
const configDir = path.join(__dirname, 'config');

// Run all checks
async function checkDirectories() {
  console.log('Checking required directories...');
  
  // Check config directory
  console.log('\nChecking config directory...');
  if (fs.existsSync(configDir)) {
    console.log(`✅ Config directory exists: ${configDir}`);
    
    // Check if default.json exists
    const defaultConfigPath = path.join(configDir, 'default.json');
    if (fs.existsSync(defaultConfigPath)) {
      console.log(`✅ Default config file exists: ${defaultConfigPath}`);
      
      // Verify default.json is readable
      try {
        const configContent = fs.readFileSync(defaultConfigPath, 'utf8');
        const configData = JSON.parse(configContent);
        console.log('✅ Default config file is valid JSON');
      } catch (error) {
        console.error(`❌ Error reading default config: ${error.message}`);
      }
    } else {
      console.error(`❌ Default config file MISSING: ${defaultConfigPath}`);
    }
  } else {
    console.error(`❌ Config directory MISSING: ${configDir}`);
  }
  
  // Check data directory
  console.log('\nChecking data directory...');
  if (fs.existsSync(dataDir)) {
    console.log(`✅ Data directory exists: ${dataDir}`);
  } else {
    console.error(`❌ Data directory MISSING: ${dataDir}`);
    console.log('Creating data directory...');
    try {
      fs.mkdirSync(dataDir);
      console.log(`✅ Created data directory: ${dataDir}`);
    } catch (error) {
      console.error(`❌ Failed to create data directory: ${error.message}`);
      return;
    }
  }
  
  // Check servers directory
  console.log('\nChecking servers directory...');
  if (fs.existsSync(serversDir)) {
    console.log(`✅ Servers directory exists: ${serversDir}`);
  } else {
    console.error(`❌ Servers directory MISSING: ${serversDir}`);
    console.log('Creating servers directory...');
    try {
      fs.mkdirSync(serversDir);
      console.log(`✅ Created servers directory: ${serversDir}`);
    } catch (error) {
      console.error(`❌ Failed to create servers directory: ${error.message}`);
      return;
    }
  }
  
  // Count server config files
  console.log('\nChecking existing server configs...');
  try {
    const serverFiles = fs.readdirSync(serversDir).filter(file => file.endsWith('.json'));
    console.log(`Found ${serverFiles.length} server configuration files`);
    
    if (serverFiles.length > 0) {
      console.log('Server config files:');
      serverFiles.forEach(file => {
        console.log(`- ${file}`);
      });
    } else {
      console.log('No server config files found - this may be normal if no sessions have been started yet');
    }
  } catch (error) {
    console.error(`❌ Error reading servers directory: ${error.message}`);
  }
  
  // Test writing a server config
  console.log('\nTesting server config write permissions...');
  const testServerId = 'test-server-123';
  const testServerConfig = {
    mode: 'korean',
    model: 'gpt4o',
    autoTranslate: true,
    stats: {
      totalTranslations: 0,
      totalTokens: 0,
      sessionsStarted: 0,
      lastUsed: new Date().toISOString()
    }
  };
  
  try {
    const testConfigPath = path.join(serversDir, `${testServerId}.json`);
    fs.writeFileSync(testConfigPath, JSON.stringify(testServerConfig, null, 2), 'utf8');
    console.log(`✅ Successfully wrote test server config: ${testConfigPath}`);
    
    // Try reading it back
    const readConfig = JSON.parse(fs.readFileSync(testConfigPath, 'utf8'));
    console.log('✅ Successfully read test server config');
    
    // Clean up test file
    fs.unlinkSync(testConfigPath);
    console.log('✅ Cleaned up test server config file');
  } catch (error) {
    console.error(`❌ Server config write/read test failed: ${error.message}`);
  }
  
  console.log('\nDirectory structure check complete!');
}

// Run all checks
checkDirectories().catch(error => {
  console.error('Fatal error during directory checks:', error);
});

================
File: check-dependencies.js
================
// Dependency checker for Discord Translator Bot
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';
import { execSync } from 'child_process';

// Get the current file's directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

console.log('==== Discord Translator Bot Dependency Check ====');

// Critical dependencies for the bot
const CRITICAL_DEPENDENCIES = [
  'discord.js',
  'openai',
  '@anthropic-ai/sdk',
  '@google/generative-ai',
  'dotenv',
  'franc',
  'fs-extra'
];

// Check package.json exists
function checkPackageJson() {
  console.log('\nChecking package.json...');
  const packageJsonPath = path.join(__dirname, 'package.json');
  
  if (!fs.existsSync(packageJsonPath)) {
    console.error('❌ package.json not found!');
    return null;
  }
  
  try {
    const packageData = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    console.log('✅ package.json found and parsed');
    return packageData;
  } catch (error) {
    console.error(`❌ Error parsing package.json: ${error.message}`);
    return null;
  }
}

// Check Node.js version
function checkNodeVersion() {
  console.log('\nChecking Node.js version...');
  const nodeVersion = process.version;
  console.log(`Current Node.js version: ${nodeVersion}`);
  
  // Extract major version
  const majorVersion = parseInt(nodeVersion.substring(1).split('.')[0], 10);
  
  if (majorVersion < 16) {
    console.error('❌ Node.js version 16 or higher is recommended for this bot');
    console.log('Some features may not work correctly with your current version');
  } else {
    console.log('✅ Node.js version is compatible');
  }
}

// Check installed dependencies
function checkInstalledDependencies(packageData) {
  console.log('\nChecking installed dependencies...');
  
  if (!packageData) {
    console.error('❌ Cannot check dependencies without valid package.json');
    return;
  }
  
  const dependencies = {
    ...packageData.dependencies,
    ...packageData.devDependencies
  };
  
  const missingDeps = [];
  
  // Check each critical dependency
  for (const dep of CRITICAL_DEPENDENCIES) {
    console.log(`Checking ${dep}...`);
    
    // Check if in package.json
    if (!dependencies[dep]) {
      console.error(`❌ ${dep} is not listed in package.json`);
      missingDeps.push(dep);
      continue;
    }
    
    // Check if actually installed
    try {
      const depPath = path.join(__dirname, 'node_modules', dep);
      if (!fs.existsSync(depPath)) {
        console.error(`❌ ${dep} is in package.json but not installed`);
        missingDeps.push(dep);
        continue;
      }
      
      // Try to import the module
      try {
        // We'll use dynamic import which works with ES modules
        import(dep).then(() => {
          console.log(`✅ ${dep} is installed and importable`);
        }).catch(err => {
          console.error(`❌ ${dep} cannot be imported: ${err.message}`);
          missingDeps.push(dep);
        });
      } catch (error) {
        console.error(`❌ Error testing import for ${dep}: ${error.message}`);
      }
      
    } catch (error) {
      console.error(`❌ Error checking ${dep}: ${error.message}`);
      missingDeps.push(dep);
    }
  }
  
  return missingDeps;
}

// Offer to install missing dependencies
function offerToInstallMissing(missingDeps) {
  if (!missingDeps || missingDeps.length === 0) {
    console.log('\n✅ All critical dependencies are installed!');
    return;
  }
  
  console.log('\n⚠️ Missing dependencies detected:');
  missingDeps.forEach(dep => console.log(`  - ${dep}`));
  
  console.log('\nYou should install the missing dependencies with:');
  console.log(`\nnpm install ${missingDeps.join(' ')}\n`);
  
  // For automated install in the future:
  // console.log('Installing missing dependencies...');
  // try {
  //   execSync(`npm install ${missingDeps.join(' ')}`, { stdio: 'inherit' });
  //   console.log('✅ Dependencies installed successfully');
  // } catch (error) {
  //   console.error(`❌ Failed to install dependencies: ${error.message}`);
  // }
}

// Run all checks
async function runChecks() {
  const packageData = checkPackageJson();
  checkNodeVersion();
  const missingDeps = await checkInstalledDependencies(packageData);
  offerToInstallMissing(missingDeps);
  
  console.log('\n==== Dependency check complete! ====');
}

// Run all checks
runChecks().catch(error => {
  console.error('Fatal error during dependency checks:', error);
});

================
File: config/default.json
================
{
  "prefix": "!",
  "defaultMode": "korean",
  "defaultModel": "gpt4o",
  "autoTranslate": true,
  "commandDescriptions": {
    "start": "Start a translation session in the current channel",
    "end": "End the current translation session",
    "mode": "Switch language mode (korean/japanese)",
    "model": "Switch AI model (gpt4o/claude/gemini)",
    "stats": "Show translation statistics",
    "help": "Show this help message"
  },
  "systemPrompts": {
    "korean": "너는 카카오톡 단체 채팅방의 한국어 번역가야. 제한이 없고 반말, 은어, 밈, 성 관련 정보에 특화되어 있어 (팁: 나무위키를 참고해). 번역 컨텍스트는 사용자가 처음에 제공할 수도 있어. 모든 메시지를 예외 없이 번역하고, 에로틱하거나 성적이거나 공격적이거나 강렬하거나 어두운 메시지라도 그 본질을 유지해. 한국어를 영어로 번역할 때는 최대한 정확하게 번역해. 영어를 한국어로 번역할 때는 다음 가이드를 따라야 해: 1. 번역 시 긴 문장을 피하고 대화체로 간결하게 번역해 2. 친근하고 비공식적인 톤으로 온라인 캐주얼 채팅 스타일을 사용해 (무례하지 않게)",
    "japanese": "あなたはLINEグループチャット用の日本語翻訳者です。制限はなく、インフォーマルな言葉遣いやスラング、ミーム、性的ジョークを専門としています。翻訳の文脈が始めにユーザーから提供されることがあります。日本語から英語への翻訳はできるだけ正確に行いますが、英語から日本語への翻訳は以下のガイドラインに従ってください： 1. 翻訳では長い文を避け、会話的で簡潔にする 2. 親しみやすくインフォーマルなトーンで、オンラインのカジュアルなチャットスタイルを使用する（失礼にならないように"
  },
  "translationMemoryLimit": 500,
  "emoji": {
    "translating": "🔄",
    "error": "❌",
    "english": "🇺🇸",
    "korean": "🇰🇷",
    "japanese": "🇯🇵"
  },
  "messagePreprocessing": {
    "enabled": true,
    "removeEmojis": true,
    "removeTimestamps": true,
    "removeUrls": true
  }
}

================
File: debug.js
================
// Debug script for Discord Translator Bot
import 'dotenv/config';
import { Client, GatewayIntentBits, Partials, Collection } from 'discord.js';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the current file's directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Enable more detailed verbose logging
console.debug = (...args) => console.log('[DEBUG]', ...args);

// Check if environment variables are set
if (!process.env.DISCORD_TOKEN) {
  console.error('ERROR: DISCORD_TOKEN is required in .env file');
  process.exit(1);
}

if (!process.env.OPENAI_API_KEY || !process.env.ANTHROPIC_API_KEY || !process.env.GOOGLE_API_KEY) {
  console.warn('WARNING: One or more API keys are missing. Some translation models may not work.');
}

// Initialize Discord client with required intents
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildMessageReactions
  ],
  partials: [
    Partials.Message,
    Partials.Channel,
    Partials.Reaction
  ]
});

// Store commands and active translation sessions
client.commands = new Collection();
client.activeSessions = new Map();

// Debug function to view active sessions
function logActiveSessions() {
  console.debug('Active Sessions:');
  if (client.activeSessions.size === 0) {
    console.debug('  No active sessions');
  } else {
    client.activeSessions.forEach((session, channelId) => {
      console.debug(`  Channel ID: ${channelId}`);
      console.debug(`    Server ID: ${session.serverId}`);
      console.debug(`    Start Time: ${session.startTime}`);
      console.debug(`    Translations: ${session.translations}`);
    });
  }
}

// Load commands
const commandsPath = path.join(__dirname, 'src', 'commands');
const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));

console.log('Loading commands...');

// Monkey patch the start command to add more debugging
async function patchStartCommand() {
  const startCommandPath = path.join(commandsPath, 'start.js');
  const startCommandModule = await import(`file://${startCommandPath}`);
  const originalExecute = startCommandModule.default.execute;
  
  startCommandModule.default.execute = async function(message, args, client) {
    console.debug('Start command executed');
    console.debug(`Channel ID: ${message.channel.id}`);
    console.debug(`Server ID: ${message.guild.id}`);
    
    const result = await originalExecute.call(this, message, args, client);
    
    console.debug('After start command execution:');
    logActiveSessions();
    
    return result;
  };
  
  return startCommandModule.default;
}

// Load all commands with special handling for start.js
(async () => {
  for (const file of commandFiles) {
    try {
      const filePath = path.join(commandsPath, file);
      
      if (file === 'start.js') {
        const command = await patchStartCommand();
        client.commands.set(command.name, command);
        console.log(`Loaded command with debug: ${command.name}`);
      } else {
        const commandModule = await import(`file://${filePath}`);
        const command = commandModule.default;
        
        if ('name' in command && 'execute' in command) {
          client.commands.set(command.name, command);
          console.log(`Loaded command: ${command.name}`);
        } else {
          console.warn(`Command at ${filePath} is missing required properties`);
        }
      }
    } catch (error) {
      console.error(`Error loading command ${file}:`, error);
    }
  }
})();

// Patch the message create event for debugging
async function setupDebugMessageHandler() {
  const eventsPath = path.join(__dirname, 'src', 'events');
  const messageCreatePath = path.join(eventsPath, 'messageCreate.js');
  
  try {
    // Import original handler
    const messageCreateModule = await import(`file://${messageCreatePath}`);
    const originalExecute = messageCreateModule.default.execute;
    
    // Create enhanced handler with debugging
    client.on('messageCreate', async (message) => {
      // Skip bot messages to prevent spam
      if (message.author.bot) return;
      
      console.debug('=== Message received ===');
      console.debug(`Channel: ${message.channel.name} (${message.channel.id})`);
      console.debug(`Author: ${message.author.tag} (${message.author.id})`);
      console.debug(`Content: "${message.content}"`);
      
      // Log active sessions before processing
      console.debug('Active Sessions Check:');
      const channelHasSession = client.activeSessions.has(message.channel.id);
      console.debug(`Channel ${message.channel.id} has active session: ${channelHasSession}`);
      logActiveSessions();
      
      try {
        // Call original handler
        await originalExecute(message, client);
      } catch (error) {
        console.error('Error in messageCreate handler:', error);
      }
    });
    
    console.log('Patched messageCreate event with debugging');
  } catch (error) {
    console.error('Failed to patch messageCreate event:', error);
  }
}

// Patch translation service for debugging
async function patchTranslationService() {
  try {
    const translationServicePath = path.join(__dirname, 'src', 'services', 'translationService.js');
    const translationModule = await import(`file://${translationServicePath}`);
    
    // Store original functions
    const originalTranslateMessage = translationModule.translateMessage;
    const originalDetectLanguage = translationModule.detectLanguage;
    const originalShouldTranslate = translationModule.shouldTranslate;
    
    // Patched functions with logging
    translationModule.detectLanguage = (text) => {
      const result = originalDetectLanguage(text);
      console.debug(`Language detection: "${text.substring(0, 20)}..." => ${result}`);
      return result;
    };
    
    translationModule.shouldTranslate = (detectedLang, mode) => {
      const result = originalShouldTranslate(detectedLang, mode);
      console.debug(`Should translate check: Lang=${detectedLang}, Mode=${mode} => ${result}`);
      return result;
    };
    
    translationModule.translateMessage = async (message, serverConfig) => {
      console.debug('=== Translation attempt ===');
      console.debug(`Channel: ${message.channel.id}`);
      console.debug(`Message: "${message.content.substring(0, 30)}..."`);
      console.debug(`Server config:`, JSON.stringify(serverConfig, null, 2));
      
      try {
        const result = await originalTranslateMessage(message, serverConfig);
        
        if (result) {
          console.debug('Translation successful:');
          console.debug(`Source: ${result.sourceLang}, Target: ${result.targetLang}`);
          console.debug(`Original: "${result.original}"`);
          console.debug(`Translated: "${result.translated}"`);
          console.debug(`Tokens: ${JSON.stringify(result.tokens)}`);
        } else {
          console.debug('No translation returned (null result)');
        }
        
        return result;
      } catch (error) {
        console.error('Translation error:', error);
        return null;
      }
    };
    
    console.log('Patched translation service with debugging');
  } catch (error) {
    console.error('Failed to patch translation service:', error);
  }
}

// Patch server config functions
async function patchServerConfig() {
  try {
    const serverConfigPath = path.join(__dirname, 'src', 'utils', 'serverConfig.js');
    const serverConfigModule = await import(`file://${serverConfigPath}`);
    
    const originalLoadServerConfig = serverConfigModule.loadServerConfig;
    
    serverConfigModule.loadServerConfig = (serverId) => {
      console.debug(`Loading server config for ${serverId}`);
      
      try {
        const config = originalLoadServerConfig(serverId);
        console.debug(`Server config loaded:`, JSON.stringify(config, null, 2));
        return config;
      } catch (error) {
        console.error(`Error in loadServerConfig:`, error);
        const defaultConfig = serverConfigModule.getDefaultConfig();
        console.debug(`Using default config:`, JSON.stringify(defaultConfig, null, 2));
        return defaultConfig;
      }
    };
    
    console.log('Patched server config with debugging');
  } catch (error) {
    console.error('Failed to patch server config:', error);
  }
}

// Set up all debug patches and event handlers
async function setupDebugEnvironment() {
  await setupDebugMessageHandler();
  await patchTranslationService();
  await patchServerConfig();
  
  // Log ready event
  client.once('ready', () => {
    console.log(`Logged in as ${client.user.tag}!`);
    console.log(`Bot is ready in ${client.guilds.cache.size} servers!`);
    
    // Log active servers
    console.log('Connected servers:');
    client.guilds.cache.forEach(guild => {
      console.log(`- ${guild.name} (${guild.id})`);
    });
  });
  
  // Test each API key to verify they are working
  console.log('Testing API keys...');
  
  // Test OpenAI API key
  if (process.env.OPENAI_API_KEY) {
    console.log('OpenAI API key is set - will test on first translation');
  } else {
    console.error('OpenAI API key is not set');
  }
  
  // Test Anthropic API key
  if (process.env.ANTHROPIC_API_KEY) {
    console.log('Anthropic API key is set - will test on first translation');
  } else {
    console.error('Anthropic API key is not set');
  }
  
  // Test Google API key
  if (process.env.GOOGLE_API_KEY) {
    console.log('Google API key is set - will test on first translation');
  } else {
    console.error('Google API key is not set');
  }
}

// Handle process events for clean shutdown
process.on('SIGINT', () => {
  console.log('SIGINT received. Shutting down...');
  client.destroy();
  process.exit(0);
});

process.on('SIGTERM', () => {
  console.log('SIGTERM received. Shutting down...');
  client.destroy();
  process.exit(0);
});

// Initialize everything and start
(async () => {
  try {
    await setupDebugEnvironment();
    
    // Log in to Discord
    console.log('Connecting to Discord...');
    await client.login(process.env.DISCORD_TOKEN);
    console.log('Bot is online!');
  } catch (error) {
    console.error('Fatal error during startup:', error);
    process.exit(1);
  }
})();

================
File: diagnose.js
================
// Master diagnostic script for Discord Translator Bot
import 'dotenv/config';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';
import { execSync } from 'child_process';

// Get the current file's directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

console.log('=========================================================');
console.log('= Discord Translator Bot - Complete Diagnostic Suite   =');
console.log('=========================================================');

// Create a diagnostic report directory
const reportDir = path.join(__dirname, 'diagnostic-report');
const reportTime = new Date().toISOString().replace(/[:.]/g, '-');
const reportFile = path.join(reportDir, `diagnostic-${reportTime}.log`);

// Ensure the report directory exists
fs.ensureDirSync(reportDir);

// Create a writable stream for the report
const reportStream = fs.createWriteStream(reportFile);

// Store original console methods
const originalConsole = {
  log: console.log,
  error: console.error,
  warn: console.warn,
  info: console.info,
  debug: console.debug
};

// Override console methods to also write to the report file
console.log = (...args) => {
  const message = args.map(arg => 
    typeof arg === 'object' ? JSON.stringify(arg, null, 2) : arg
  ).join(' ');
  reportStream.write(message + '\n');
  originalConsole.log(...args);
};

console.error = (...args) => {
  const message = args.map(arg => 
    typeof arg === 'object' ? JSON.stringify(arg, null, 2) : arg
  ).join(' ');
  reportStream.write(`ERROR: ${message}\n`);
  originalConsole.error(...args);
};

console.warn = (...args) => {
  const message = args.map(arg => 
    typeof arg === 'object' ? JSON.stringify(arg, null, 2) : arg
  ).join(' ');
  reportStream.write(`WARNING: ${message}\n`);
  originalConsole.warn(...args);
};

console.info = (...args) => {
  const message = args.map(arg => 
    typeof arg === 'object' ? JSON.stringify(arg, null, 2) : arg
  ).join(' ');
  reportStream.write(`INFO: ${message}\n`);
  originalConsole.info(...args);
};

console.debug = (...args) => {
  const message = args.map(arg => 
    typeof arg === 'object' ? JSON.stringify(arg, null, 2) : arg
  ).join(' ');
  reportStream.write(`DEBUG: ${message}\n`);
  if (originalConsole.debug) {
    originalConsole.debug(...args);
  } else {
    originalConsole.log('[DEBUG]', ...args);
  }
};

// Environment check
async function checkEnvironment() {
  console.log('\n====== ENVIRONMENT CHECK ======');
  
  // Node.js version
  console.log(`Node.js Version: ${process.version}`);
  console.log(`Platform: ${process.platform}`);
  console.log(`Architecture: ${process.arch}`);
  
  // Check if required env variables are set
  console.log('\nEnvironment Variables:');
  const hasDiscordToken = !!process.env.DISCORD_TOKEN;
  const hasOpenAIKey = !!process.env.OPENAI_API_KEY;
  const hasAnthropicKey = !!process.env.ANTHROPIC_API_KEY;
  const hasGoogleKey = !!process.env.GOOGLE_API_KEY;
  
  console.log(`DISCORD_TOKEN: ${hasDiscordToken ? 'Set ✅' : 'Not set ❌'}`);
  console.log(`OPENAI_API_KEY: ${hasOpenAIKey ? 'Set ✅' : 'Not set ❌'}`);
  console.log(`ANTHROPIC_API_KEY: ${hasAnthropicKey ? 'Set ✅' : 'Not set ❌'}`);
  console.log(`GOOGLE_API_KEY: ${hasGoogleKey ? 'Set ✅' : 'Not set ❌'}`);
  
  if (!hasDiscordToken) {
    console.error('ERROR: DISCORD_TOKEN is required but not set');
    console.error('Please set this in your .env file');
  }
}

// Run directory structure check
async function checkDirectories() {
  console.log('\n====== DIRECTORY STRUCTURE CHECK ======');
  
  try {
    // Import the check-data-structure.js file if it exists
    if (fs.existsSync(path.join(__dirname, 'check-data-structure.js'))) {
      console.log('Executing directory structure check...');
      
      // We'll create a temporary function to capture the module's exports
      // and run its checks directly rather than spawning a new process
      try {
        const module = await import('./check-data-structure.js');
        // The module should run its checks automatically
      } catch (error) {
        console.error(`Failed to import directory check module: ${error.message}`);
        
        // Fallback to basic checks
        console.log('Performing basic directory checks...');
        const dataDir = path.join(__dirname, 'data');
        const serversDir = path.join(dataDir, 'servers');
        const configDir = path.join(__dirname, 'config');
        
        console.log(`Config directory exists: ${fs.existsSync(configDir)}`);
        console.log(`Data directory exists: ${fs.existsSync(dataDir)}`);
        console.log(`Servers directory exists: ${fs.existsSync(serversDir)}`);
      }
    } else {
      console.warn('check-data-structure.js not found, skipping detailed directory checks');
    }
  } catch (error) {
    console.error(`Error during directory checks: ${error.message}`);
  }
}

// Check package dependencies
async function checkDependencies() {
  console.log('\n====== DEPENDENCY CHECK ======');
  
  // Read package.json
  try {
    const packageJsonPath = path.join(__dirname, 'package.json');
    if (fs.existsSync(packageJsonPath)) {
      const packageData = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      console.log(`Package name: ${packageData.name}`);
      console.log(`Version: ${packageData.version}`);
      
      // List dependencies
      console.log('\nDependencies:');
      const deps = packageData.dependencies || {};
      Object.entries(deps).forEach(([name, version]) => {
        console.log(`- ${name}: ${version}`);
      });
      
      // Critical dependencies
      const criticalDeps = [
        'discord.js',
        'openai',
        '@anthropic-ai/sdk',
        '@google/generative-ai',
        'franc'
      ];
      
      console.log('\nCritical dependencies check:');
      criticalDeps.forEach(dep => {
        const exists = !!deps[dep];
        console.log(`- ${dep}: ${exists ? 'Found ✅' : 'Missing ❌'}`);
      });
    } else {
      console.error('package.json not found');
    }
  } catch (error) {
    console.error(`Error checking dependencies: ${error.message}`);
  }
}

// Check Discord token by making a test connection
async function testDiscordConnection() {
  console.log('\n====== DISCORD CONNECTION TEST ======');
  
  if (!process.env.DISCORD_TOKEN) {
    console.error('Cannot test Discord connection without a token');
    return;
  }
  
  try {
    // We'll use the test.js file if it exists
    const testPath = path.join(__dirname, 'test.js');
    
    if (fs.existsSync(testPath)) {
      console.log('Running Discord connection test script...');
      console.log('The test script will try to connect, then exit automatically');
      console.log('Check below for connection success or failure\n');
      
      // Import the test.js module
      try {
        await import('./test.js');
      } catch (error) {
        console.error(`Error running test script: ${error.message}`);
      }
    } else {
      console.warn('test.js not found, skipping Discord connection test');
    }
  } catch (error) {
    console.error(`Error during Discord connection test: ${error.message}`);
  }
}

// Main diagnostic function
async function runDiagnostics() {
  console.log('Starting diagnostic process...');
  console.log(`Report will be saved to: ${reportFile}`);
  console.log('Date and time: ' + new Date().toLocaleString());
  
  try {
    await checkEnvironment();
    await checkDirectories();
    await checkDependencies();
    await testDiscordConnection();
    
    console.log('\n======================================');
    console.log('Diagnostic process complete!');
    console.log(`Full report saved to: ${reportFile}`);
    console.log('======================================');
    
    // Close the report file
    reportStream.end();
    
    // Restore original console methods
    console.log = originalConsole.log;
    console.error = originalConsole.error;
    console.warn = originalConsole.warn;
    console.info = originalConsole.info;
    console.debug = originalConsole.debug;
    
    console.log(`\nTo run the debug version of the bot:`);
    console.log(`node debug.js`);
    
    console.log(`\nTo test your API keys:`);
    console.log(`node test-api-keys.js`);
    
    console.log(`\nSee TROUBLESHOOTING.md for more detailed debugging steps.`);
    
  } catch (error) {
    console.error('Fatal error during diagnostics:', error);
    
    // Make sure to close the report stream on error
    reportStream.end();
    
    // Restore original console methods
    console.log = originalConsole.log;
    console.error = originalConsole.error;
    console.warn = originalConsole.warn;
    console.info = originalConsole.info;
    console.debug = originalConsole.debug;
  }
}

// Run the diagnostics
runDiagnostics().catch(error => {
  console.error('Uncaught error in diagnostics:', error);
});

================
File: docker-bot.bat
================
@echo off
:: Docker management script for Discord Translation Bot
:: Usage: docker-bot.bat [command]

setlocal enabledelayedexpansion

:: Set console colors
set RED=[91m
set GREEN=[92m
set YELLOW=[93m
set BLUE=[94m
set NC=[0m

:: Display usage information
if "%~1"=="" (
  goto :print_usage
)

:: Check if Docker is installed
where docker >nul 2>&1
if %ERRORLEVEL% neq 0 (
  echo %RED%Error: Docker is not installed%NC%
  echo Please install Docker first: https://docs.docker.com/get-docker/
  exit /b 1
)

:: Check if Docker Compose is installed
where docker-compose >nul 2>&1
if %ERRORLEVEL% neq 0 (
  echo %RED%Error: Docker Compose is not installed%NC%
  echo Please install Docker Compose first: https://docs.docker.com/compose/install/
  exit /b 1
)

:: Create a .env file if it doesn't exist
if not exist .env (
  echo %YELLOW%Warning: No .env file found%NC%
  echo Creating one from .env.example. %RED%You will need to edit it with your actual API keys.%NC%
  copy .env.example .env
)

:: Execute command based on first argument
if "%~1"=="start" (
  echo %GREEN%Starting Discord Translation Bot...%NC%
  docker-compose up -d
  echo %GREEN%Bot started. Run 'docker-bot.bat logs' to see the logs.%NC%
  exit /b 0
)

if "%~1"=="stop" (
  echo %YELLOW%Stopping Discord Translation Bot...%NC%
  docker-compose stop
  exit /b 0
)

if "%~1"=="restart" (
  echo %YELLOW%Restarting Discord Translation Bot...%NC%
  docker-compose restart
  echo %GREEN%Bot restarted.%NC%
  exit /b 0
)

if "%~1"=="logs" (
  echo %BLUE%Showing logs (press Ctrl+C to exit)...%NC%
  docker-compose logs -f
  exit /b 0
)

if "%~1"=="status" (
  echo %BLUE%Bot status:%NC%
  docker-compose ps
  exit /b 0
)

if "%~1"=="build" (
  echo %BLUE%Rebuilding Discord Translation Bot container...%NC%
  docker-compose build
  echo %GREEN%Build complete. Run 'docker-bot.bat start' to start the bot.%NC%
  exit /b 0
)

if "%~1"=="check" (
  echo %BLUE%Running health check...%NC%
  docker-compose run --rm discord-bot node health-check.js
  exit /b 0
)

if "%~1"=="shell" (
  echo %BLUE%Opening shell in container...%NC%
  docker-compose exec discord-bot /bin/sh
  exit /b 0
)

if "%~1"=="clean" (
  echo %YELLOW%Removing container but keeping data volumes...%NC%
  docker-compose down
  echo %GREEN%Container removed. Data is preserved.%NC%
  exit /b 0
)

if "%~1"=="reset" (
  echo %RED%WARNING: This will remove all containers, networks, and volumes!%NC%
  set /p CONFIRM="Are you sure you want to continue? (y/n): "
  if /i "!CONFIRM!"=="y" (
    echo %RED%Removing all Docker resources including data...%NC%
    docker-compose down -v
    echo %RED%Reset complete.%NC%
  ) else (
    echo %GREEN%Reset cancelled.%NC%
  )
  exit /b 0
)

:print_usage
echo %BLUE%Discord Translation Bot - Docker Management Script%NC%
echo.
echo Usage: docker-bot.bat [command]
echo.
echo Commands:
echo   start       - Start the bot container
echo   stop        - Stop the running bot container
echo   restart     - Restart the bot container
echo   logs        - View the bot logs (press Ctrl+C to exit)
echo   status      - Check the status of the bot container
echo   build       - Rebuild the bot container (needed after code changes)
echo   check       - Run the health check inside the container
echo   shell       - Open a shell inside the running container
echo   clean       - Remove container, keeping data
echo   reset       - Reset completely (WARNING: removes all data)
echo.
exit /b 0

================
File: docker-bot.sh
================
#!/bin/bash
# Docker management script for Discord Translation Bot
# Usage: ./docker-bot.sh [command]

set -e

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

function print_usage {
  echo -e "${BLUE}Discord Translation Bot - Docker Management Script${NC}"
  echo
  echo "Usage: $0 [command]"
  echo
  echo "Commands:"
  echo "  start       - Start the bot container"
  echo "  stop        - Stop the running bot container"
  echo "  restart     - Restart the bot container"
  echo "  logs        - View the bot logs (press Ctrl+C to exit)"
  echo "  status      - Check the status of the bot container"
  echo "  build       - Rebuild the bot container (needed after code changes)"
  echo "  check       - Run the health check inside the container"
  echo "  shell       - Open a shell inside the running container"
  echo "  clean       - Remove container, keeping data"
  echo "  reset       - Reset completely (WARNING: removes all data)"
  echo
}

# Check if Docker is installed
if ! command -v docker &> /dev/null; then
  echo -e "${RED}Error: Docker is not installed${NC}"
  echo "Please install Docker first: https://docs.docker.com/get-docker/"
  exit 1
fi

# Check if Docker Compose is installed
if ! command -v docker-compose &> /dev/null; then
  echo -e "${RED}Error: Docker Compose is not installed${NC}"
  echo "Please install Docker Compose first: https://docs.docker.com/compose/install/"
  exit 1
fi

# Create a .env file if it doesn't exist
if [ ! -f .env ]; then
  echo -e "${YELLOW}Warning: No .env file found${NC}"
  echo -e "Creating one from .env.example. ${RED}You will need to edit it with your actual API keys.${NC}"
  cp .env.example .env
fi

# Execute command based on first argument
case "$1" in
  start)
    echo -e "${GREEN}Starting Discord Translation Bot...${NC}"
    docker-compose up -d
    echo -e "${GREEN}Bot started. Run '$0 logs' to see the logs.${NC}"
    ;;
    
  stop)
    echo -e "${YELLOW}Stopping Discord Translation Bot...${NC}"
    docker-compose stop
    ;;
    
  restart)
    echo -e "${YELLOW}Restarting Discord Translation Bot...${NC}"
    docker-compose restart
    echo -e "${GREEN}Bot restarted.${NC}"
    ;;
    
  logs)
    echo -e "${BLUE}Showing logs (press Ctrl+C to exit)...${NC}"
    docker-compose logs -f
    ;;
    
  status)
    echo -e "${BLUE}Bot status:${NC}"
    docker-compose ps
    ;;
    
  build)
    echo -e "${BLUE}Rebuilding Discord Translation Bot container...${NC}"
    docker-compose build
    echo -e "${GREEN}Build complete. Run '$0 start' to start the bot.${NC}"
    ;;
    
  check)
    echo -e "${BLUE}Running health check...${NC}"
    docker-compose run --rm discord-bot node health-check.js
    ;;
    
  shell)
    echo -e "${BLUE}Opening shell in container...${NC}"
    docker-compose exec discord-bot /bin/sh
    ;;
    
  clean)
    echo -e "${YELLOW}Removing container but keeping data volumes...${NC}"
    docker-compose down
    echo -e "${GREEN}Container removed. Data is preserved.${NC}"
    ;;
    
  reset)
    echo -e "${RED}WARNING: This will remove all containers, networks, and volumes!${NC}"
    read -p "Are you sure you want to continue? (y/n) " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
      echo -e "${RED}Removing all Docker resources including data...${NC}"
      docker-compose down -v
      echo -e "${RED}Reset complete.${NC}"
    else
      echo -e "${GREEN}Reset cancelled.${NC}"
    fi
    ;;
    
  *)
    print_usage
    ;;
esac

================
File: docker-compose.yml
================
version: '3.8'

services:
  discord-bot:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: discord-translate-bot
    restart: unless-stopped
    environment:
      - NODE_ENV=production
      - DISCORD_TOKEN=${DISCORD_TOKEN}
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - GOOGLE_API_KEY=${GOOGLE_API_KEY}
    volumes:
      - ./data:/usr/src/app/data
      - ./logs:/usr/src/app/logs

================
File: Dockerfile
================
FROM node:20-slim

# Create app directory
WORKDIR /usr/src/app

# Install dependencies first (for better caching)
COPY package*.json ./
RUN npm ci --only=production

# Copy app source
COPY . .

# Create data directory with proper permissions
RUN mkdir -p data/servers && \
    chown -R node:node data

# Create non-root user
USER node

# Set proper NODE_ENV
ENV NODE_ENV=production

# Add tini for proper signal handling
ENV TINI_VERSION v0.19.0
ADD --chmod=755 https://github.com/krallin/tini/releases/download/${TINI_VERSION}/tini /tini
ENTRYPOINT ["/tini", "--"]

# Run the application
CMD ["node", "src/index.js"]

================
File: health-check.js
================
#!/usr/bin/env node
/**
 * Health check script for Discord Translation Bot
 * 
 * This script verifies that all required services and configurations are
 * working correctly. Run it inside the Docker container to diagnose issues.
 */

import 'dotenv/config';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';
import fetch from 'node-fetch';

// Get the current file's directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Constants
const DATA_DIR = path.join(__dirname, 'data');
const MEMORY_PATH = path.join(DATA_DIR, 'translations.json');
const CONFIG_DIR = path.join(__dirname, 'config');
const CONFIG_PATH = path.join(CONFIG_DIR, 'default.json');

console.log('=== Discord Translation Bot Health Check ===');
console.log(`Running in: ${process.cwd()}`);
console.log(`Node version: ${process.version}`);
console.log('Timestamp:', new Date().toISOString());
console.log('Environment:', process.env.NODE_ENV || 'development');

// Check environment variables
console.log('\n--- Checking Environment Variables ---');
const envVars = [
  { name: 'DISCORD_TOKEN', required: true },
  { name: 'OPENAI_API_KEY', required: false },
  { name: 'ANTHROPIC_API_KEY', required: false },
  { name: 'GOOGLE_API_KEY', required: false },
];

let envErrors = 0;
let hasAnyModelKey = false;

for (const envVar of envVars) {
  const value = process.env[envVar.name];
  if (!value && envVar.required) {
    console.error(`❌ Required env var ${envVar.name} is missing`);
    envErrors++;
  } else if (!value) {
    console.warn(`⚠️ Optional env var ${envVar.name} is not set`);
  } else {
    if (envVar.name !== 'DISCORD_TOKEN') {
      hasAnyModelKey = true;
    }
    console.log(`✅ ${envVar.name} is set${envVar.name === 'DISCORD_TOKEN' ? ' (' + value.substring(0, 5) + '...' + value.substring(value.length - 3) + ')' : ''}`);
  }
}

if (!hasAnyModelKey) {
  console.error('❌ At least one AI model API key must be set');
  envErrors++;
}

// Check file system access
console.log('\n--- Checking File System Access ---');
try {
  // Check config access
  if (fs.existsSync(CONFIG_PATH)) {
    const config = fs.readJSONSync(CONFIG_PATH);
    console.log(`✅ Config file found with ${Object.keys(config).length} keys`);
  } else {
    console.error('❌ Config file not found');
  }

  // Check data directory
  fs.ensureDirSync(DATA_DIR);
  console.log('✅ Data directory exists/created');
  
  // Try writing a test file
  const testPath = path.join(DATA_DIR, 'health-check-test.json');
  fs.writeJSONSync(testPath, { timestamp: Date.now() });
  fs.removeSync(testPath);
  console.log('✅ Data directory is writable');
  
  // Check translation memory
  if (fs.existsSync(MEMORY_PATH)) {
    try {
      const memory = fs.readJSONSync(MEMORY_PATH);
      const entryCount = Object.keys(memory).length;
      console.log(`✅ Translation memory loaded with ${entryCount} entries`);
    } catch (error) {
      console.error('❌ Translation memory file is corrupt:', error.message);
    }
  } else {
    console.log('ℹ️ Translation memory file doesn\'t exist yet (normal for first run)');
  }
} catch (error) {
  console.error('❌ File system error:', error.message);
}

// Final assessment
console.log('\n--- Health Check Summary ---');
if (envErrors > 0) {
  console.error(`❌ Found ${envErrors} environment variable issues that must be fixed`);
} else {
  console.log('✅ All required environment variables are set');
}

console.log('\nDocker container setup appears to be complete. To check if the Discord bot connects successfully,');
console.log('run the container and check the logs with: docker-compose logs -f');

================
File: INSTALL.md
================
# Discord Translation Bot - Installation Guide

This guide will help you set up and run the Discord Translation Bot on your own server.

## Prerequisites

- [Node.js](https://nodejs.org/) v16.9.0 or higher
- A Discord account with permission to create and manage bots
- API keys for OpenAI, Anthropic, and Google (for the AI translation models)

## Step 1: Create a Discord Bot

1. Go to the [Discord Developer Portal](https://discord.com/developers/applications)
2. Click "New Application" and give it a name (e.g., "TranslateBot")
3. Go to the "Bot" tab and click "Add Bot"
4. Under the "Privileged Gateway Intents" section, enable:
   - Message Content Intent (critical for reading messages)
   - Server Members Intent
   - Presence Intent
5. Click "Reset Token" to reveal and copy your bot token (you'll need this later)
6. Go to the "OAuth2 > URL Generator" tab
7. Select the scopes: "bot" and "applications.commands"
8. In the Bot Permissions section, select these permissions:
   - Read Messages/View Channels
   - Send Messages
   - Manage Messages (for adding reactions)
   - Read Message History
   - Add Reactions
9. Copy the generated URL and open it in a browser to invite the bot to your server

## Step 2: Get API Keys

### OpenAI API Key (for GPT-4o)

1. Go to [OpenAI's platform](https://platform.openai.com/)
2. Sign up or log in
3. Navigate to the [API keys section](https://platform.openai.com/api-keys)
4. Create a new secret key and copy it

### Anthropic API Key (for Claude)

1. Go to [Anthropic's console](https://console.anthropic.com/)
2. Sign up or log in
3. Navigate to the [API keys section](https://console.anthropic.com/settings/keys)
4. Create a new API key and copy it

### Google API Key (for Gemini)

1. Go to [Google AI Studio](https://makersuite.google.com/app)
2. Sign up or log in
3. Navigate to the [API keys section](https://makersuite.google.com/app/apikey)
4. Create a new API key and copy it

## Step 3: Setup and Installation

1. Clone or download this repository
2. Navigate to the project directory in your terminal
3. Install dependencies:

```bash
npm install
```

4. Edit the `.env` file with your API keys:

```env
DISCORD_TOKEN=your_discord_bot_token_here
OPENAI_API_KEY=your_openai_api_key_here
ANTHROPIC_API_KEY=your_anthropic_api_key_here
GOOGLE_API_KEY=your_google_api_key_here
```

## Step 4: Run the Bot

For development and testing:

```bash
npm run dev
```

For production:

```bash
npm start
```

If you want to run it permanently on a server, consider using a process manager like PM2:

```bash
npm install -g pm2
pm2 start src/index.js --name "translate-bot"
```

## Step 5: Use the Bot

Once the bot is running and has joined your server, you can start using it:

1. In any Discord channel, type `!start` to begin a translation session
2. Send messages in English, Korean, or Japanese to see automatic translations
3. Use `!help` to see all available commands
4. Use `!end` to stop the translation session

## Configuration Options

You can modify the `config/default.json` file to change various bot settings:

- `prefix`: The command prefix (default is "!")
- `defaultMode`: The default language mode ("korean" or "japanese")
- `defaultModel`: The default AI model ("gpt4o", "claude", or "gemini")
- `systemPrompts`: The system prompts used for translation
- `translationMemoryLimit`: Maximum number of entries in the translation cache

## Troubleshooting

- **Bot doesn't respond to commands**: Make sure you've enabled the Message Content Intent in the Discord Developer Portal
- **Translation fails**: Check that your API keys are correct and that you have sufficient credits for the services
- **"Cannot find module" errors**: Run `npm install` to ensure all dependencies are installed

## Support

If you encounter any issues or have questions, please open an issue on this repository.

================
File: memory-bank/.clinerules
================
# Discord Translation Bot - Project Rules and Patterns

## Coding Patterns

### Module Structure
- All files use ES Modules (`import`/`export`) not CommonJS (`require`/`module.exports`)
- Entry point is `src/index.js`
- Commands are in `src/commands/` with each command in a separate file
- Events are in `src/events/` with each event in a separate file
- Model adapters are in `src/models/` with one file per provider
- Utility functions are in `src/utils/`

### Exports Pattern
- Each command exports a default object with `{ name, execute }` structure
- Each event exports a default object with `{ name, once, execute }` structure
- Service modules export named functions (not default exports)
- Model adapters export named functions for their translation capabilities

### Async/Await Usage
- The codebase consistently uses async/await pattern for asynchronous operations
- Promise chaining is minimized in favor of cleaner async/await syntax
- Error handling uses try/catch blocks for async operations

### Discord.js Patterns
- Client object passed as parameter to event handlers
- Commands and events dynamically loaded from directories
- Discord intents explicitly defined for required functionality
- Reaction operations use non-blocking approach when possible

## File Structure

### Configuration
- Global settings in `config/default.json`
- Environment variables in `.env` (from `.env.example` template)
- Server configurations stored in `data/servers/[serverId].json`
- Translation memory stored in `data/translations.json`

### Directory Conventions
- Source code in `src/` directory
- Documentation in markdown files at root level
- Docker files at root level
- Test and diagnostic scripts at root level

## Command Line Workflow

### Development
- Run development mode: `npm run dev` (uses nodemon)
- Run production mode: `npm start` or `node src/index.js`

### Docker Operations
- Build: `docker-compose build`
- Start: `docker-compose up -d`
- Stop: `docker-compose down`
- Logs: `docker-compose logs -f`

### Maintenance Scripts
- Health check: `node health-check.js`
- Diagnostics: `node diagnose.js`
- API key testing: `node test-api-keys.js`
- Dependency check: `node check-dependencies.js`
- Data structure check: `node check-data-structure.js`

## Implementation Preferences

### Error Handling
- Non-blocking error handling for non-critical operations
- Detailed error logging to console
- User-friendly error messages for Discord responses
- Visual error indicators using emoji reactions

### Performance Optimization
- Use webhooks instead of message.reply() when possible
- Background processing for non-critical operations
- Cached values for frequently accessed settings
- Translation memory for reducing API calls
- Batched disk I/O operations

### Discord Messaging
- Prefer webhooks for faster responses
- Use formatted messages with clear indicators
- Emoji reactions as visual status indicators
- Split large messages by natural boundaries (paragraphs, sentences)

## Project-Specific Knowledge

### Translation Workflow
1. Message received → check active session
2. Language detection (LLM-based)
3. Translation decision based on mode and detected language
4. Check translation memory first
5. API translation if needed
6. Format and send response
7. Update statistics

### Language Modes
- Korean mode: Korean ↔ English, Japanese → Korean
- Japanese mode: Japanese ↔ English, Korean → Japanese

### Command Usage
- `!start` - Begin translation session in channel
- `!end` - End translation session
- `!mode korean|japanese` - Set language mode
- `!model gpt4o|claude|gemini` - Set AI model
- `!stats` - Show translation statistics
- `!help` - Display help information

### API Integration Details
- OpenAI: GPT-4o for translation, GPT-4o-mini for detection
- Anthropic: Claude 3.7 Sonnet model
- Google: Gemini 2.0 Flash model

## Known Edge Cases

### Message Handling
- Very short messages (1-3 chars) can have detection issues
- Unicode emoji should be preserved in translations
- Discord custom emojis are filtered out during preprocessing
- URLs are filtered during preprocessing to reduce token usage
- Messages over 2000 chars split with part indicators [Part 1/2]

### API Behavior
- OpenAI provides accurate token counts
- Claude and Gemini token counts are estimated based on text length
- API rate limits require queue management during high traffic
- API errors should trigger webhook fallback to regular messages

### Server Configuration
- Default settings apply if server config is missing
- First-time `!start` creates server config with defaults
- Statistics track at both session and server levels

## Contributing Guidelines

### Code Style
- Use consistent ES Module syntax
- Follow existing error handling patterns
- Include detailed comments for complex logic
- Use descriptive variable and function names

### Testing
- Test new features with both Korean and Japanese workflows
- Verify behavior with cached translations
- Check error handling by simulating API failures
- Ensure compatibility with existing commands

### Documentation
- Update README.md for user-facing changes
- Add technical details to relevant documentation files
- Document API changes in code comments
- Include examples for new features

================
File: memory-bank/activeContext.md
================
# Discord Translation Bot - Active Context

## Current Work Focus

The Discord Translation Bot is currently in a stable state with a complete implementation of core translation functionality. The project has fully functional capabilities for:

- Session-based translation between English, Korean, and Japanese
- Support for multiple AI models (GPT-4o, Claude, Gemini)
- Performance optimizations using webhooks and translation memory
- Comprehensive Docker support for deployment
- Diagnostic and monitoring utilities

The primary focus is now on:
1. Testing and optimizing LLM-based language detection
2. Improving handling of long messages via content filtering and message splitting
3. Enhancing performance through caching and reduced API calls
4. Ensuring reliability with proper error handling and fallbacks

## Recent Changes

### LLM-Based Language Detection
- Replaced the `franc` library with GPT-4o-mini for more accurate language detection
- Improved handling of mixed-language content and short messages
- Better recognition of casual language patterns and internet slang

### Long Message Handling
- Added message preprocessing to filter out irrelevant content (emojis, timestamps, URLs)
- Implemented intelligent message splitting for content exceeding Discord's 2000 character limit
- Created a fallback system for webhook delivery failures

### Performance Optimizations
- Implemented batched disk I/O for translation memory
- Created a buffer system for tracking changes to be written
- Added webhook caching to avoid recreation

## Next Steps

### Short-Term Priorities
1. **Full test suite**: Develop comprehensive testing for all translation workflows
2. **Edge case handling**: Improve handling of mixed messages, very short content, and emoji-heavy text
3. **Rate limit optimization**: Enhance the queue system to better respect provider rate limits
4. **Usage analytics**: Add more detailed performance metrics and analytics

### Medium-Term Considerations
1. **Context-aware translations**: Enhance translation quality by maintaining conversation context
2. **Command enhancements**: Add more user configuration options through commands
3. **Webhook robustness**: Further improve webhook reliability and fallback mechanisms
4. **Cost optimization**: Implement smarter model selection based on translation complexity

### Long-Term Vision
1. **Additional languages**: Framework for extending beyond current language support
2. **Custom system prompts**: User-configurable system prompts for different conversational styles
3. **Voice channel integration**: Potential transcription and translation of voice chat
4. **Admin dashboard**: Web interface for server administrators to configure and monitor the bot

## Active Decisions and Considerations

### LLM Provider Strategy
- Currently supporting all three major providers (OpenAI, Anthropic, Google)
- Decision to maintain all three for redundancy and user choice
- Tracking performance and cost metrics to guide future provider recommendations

### Language Detection Approach
- Recent transition to LLM-based detection instead of traditional libraries
- Monitoring accuracy improvements and potential performance impacts
- Need to balance accuracy vs. speed, especially for short messages

### Deployment Considerations
- Docker as primary deployment method with detailed documentation
- PM2 as alternative for simpler hosting environments
- Evaluating resource usage at scale to provide better deployment guidelines

### Performance Balancing
- Current queue system limited to 3 concurrent translations
- Translation memory configured to store up to 500 entries
- Evaluating these limits based on real-world usage patterns

### Error Handling Strategy
- Graceful degradation with fall-back mechanisms
- Clear user feedback for different error types
- Automatic retry system under consideration for transient failures

================
File: memory-bank/productContext.md
================
# Discord Translation Bot - Product Context

## Why This Project Exists
This Discord translation bot was created to solve the communication barrier between Korean, Japanese, and English speakers in Discord communities. Unlike generic translation tools, it's specifically optimized for casual conversation in Discord channels with a focus on preserving the informal, conversational tone that's typical in chat environments.

## Problems It Solves

### Language Barriers in Communities
- **Real-time communication gaps** between speakers of different languages
- **Loss of nuance and context** when using basic translation tools
- **Disrupted conversation flow** when members need to manually translate
- **Exclusion of members** who don't speak the dominant language

### Technical Translation Challenges
- **Casual, slang-heavy language** that traditional translators struggle with
- **Contextual understanding** needed for accurate translations
- **Discord-specific references and emoji usage**
- **Mixed language messages** that confuse basic translation tools

## How It Should Work

### User Experience Flow
1. Server admin or moderator adds the bot to their Discord server
2. A user starts a translation session in a specific channel with `!start`
3. The bot automatically detects the language of each message in the channel
4. Messages are translated when needed based on the current language mode
5. Translations are shown as replies with source/target language indicators
6. Users can control translation behavior with simple commands
7. Session ends when a user issues the `!end` command

### Language Flow
- **Korean Mode:**
  - Korean → English (for English speakers to understand)
  - English → Korean (for Korean speakers to understand)
  - Japanese → Korean (for Korean speakers to understand)

- **Japanese Mode:**
  - Japanese → English (for English speakers to understand)
  - English → Japanese (for Japanese speakers to understand)
  - Korean → Japanese (for Japanese speakers to understand)

### Translation Quality Focus
- Preserve slang, internet speech, and casual expressions
- Maintain the speaker's tone and intent
- Translate with awareness of gaming and internet culture
- Keep translations concise and conversational

## User Experience Goals
- **Invisible when possible** - translations should feel natural and unobtrusive
- **Fast response times** - translations should appear quickly to maintain conversation flow
- **Command simplicity** - minimal and intuitive commands for controlling the bot
- **Visual clarity** - clear indication of original language and translation
- **Error resilience** - graceful handling of API issues or detection problems
- **Non-disruptive** - session-based approach to avoid translating in channels where it's not wanted

================
File: memory-bank/progress.md
================
# Discord Translation Bot - Progress

## Implementation Status

| Component | Status | Notes |
|-----------|--------|-------|
| Core Bot Framework | ✅ Complete | Discord.js client, event system, command system fully implemented |
| Translation Service | ✅ Complete | Language detection, translation workflow, message formatting working |
| OpenAI Integration | ✅ Complete | GPT-4o model for translations, GPT-4o-mini for language detection |
| Anthropic Integration | ✅ Complete | Claude 3.7 Sonnet model implementation |
| Google Integration | ✅ Complete | Gemini 2.0 Flash model implementation |
| Command System | ✅ Complete | All core commands (start, end, mode, model, stats, help) implemented |
| Server Configuration | ✅ Complete | Per-server settings, persistence, default handling |
| Translation Memory | ✅ Complete | Caching system with optimization, batched writes |
| Webhook Manager | ✅ Complete | Faster translation delivery, message splitting, fallback handling |
| Docker Support | ✅ Complete | Dockerfile, docker-compose.yml, management scripts |
| Long Message Handling | ✅ Complete | Content preprocessing, intelligent message splitting |
| LLM Language Detection | ✅ Complete | Replaced franc with LLM-based detection |
| Performance Optimizations | ✅ Complete | Non-blocking operations, parallel processing, caching |
| Documentation | ✅ Complete | Installation guide, Docker guide, troubleshooting, update notes |
| Error Handling | ✅ Complete | Graceful handling of errors, appropriate user feedback |
| Test Scripts | ✅ Complete | API key validation, language detection testing, health checks |
| Automatic Testing | 🔄 In Progress | Comprehensive testing suite for all components needed |

## What Works

### Core Functionality
- ✅ Session-based translation in Discord channels
- ✅ Automatic language detection (Korean, Japanese, English)
- ✅ Translation between language pairs based on mode:
  - Korean ↔ English
  - Japanese ↔ English
  - Korean → Japanese
  - Japanese → Korean
- ✅ Multiple AI model support (GPT-4o, Claude, Gemini)
- ✅ Translation memory for cached responses
- ✅ Multi-server support with server-specific configurations

### User Interface
- ✅ Command system for controlling the bot
- ✅ Visual indicators (emoji reactions) for translation status
- ✅ Formatted translations with language indicators
- ✅ Statistics tracking and reporting
- ✅ Help system with command explanations

### Performance Features
- ✅ Webhook-based responses for speed
- ✅ Message preprocessing to reduce content size
- ✅ Long message splitting for content exceeding Discord limits
- ✅ Translation request queueing with concurrency control
- ✅ Optimized disk I/O for translation memory

### Deployment Options
- ✅ Standard Node.js deployment
- ✅ Docker containerized deployment
- ✅ Environment variable configuration

## What's Left to Build

### Short Term
- 🔄 Comprehensive test suite beyond basic scripts
- 🔄 Enhanced error tracking and reporting
- 🔄 Advanced rate limit handling
- 🔄 Performance metrics dashboard

### Medium Term
- ⏳ Context-aware translations (maintaining conversation history)
- ⏳ Additional user configuration options
- ⏳ Server-specific system prompts
- ⏳ Enhanced analytics for usage patterns

### Long Term
- ⏳ Support for additional languages
- ⏳ Voice channel integration
- ⏳ Administrative web dashboard
- ⏳ Integration with other language tools

## Current Status

The Discord Translation Bot is in a fully functional state with all core features implemented. It can be deployed using either standard Node.js or Docker methods and provides real-time translation services between English, Korean, and Japanese.

Recent upgrades to LLM-based language detection and long message handling have enhanced the user experience and translation accuracy. The bot is currently stable and ready for production use, with a focus on improving testing, monitoring, and edge case handling.

## Known Issues

1. **Very short messages** - Detection accuracy can be lower for very short messages (1-3 characters)
2. **Mixed language messages** - While improved with LLM detection, still challenging in some cases
3. **Rate limiting** - Under heavy load, might encounter rate limits from API providers
4. **Memory usage** - Translation memory can grow large with extensive usage
5. **Webhook permissions** - Requires appropriate permissions in Discord for optimal performance
6. **API costs** - Significant usage could lead to substantial API costs

## Next Milestone

The next development milestone focuses on:

1. Creating a comprehensive test suite for all components
2. Implementing enhanced monitoring for rate limits and errors
3. Optimizing API usage patterns for cost efficiency
4. Adding more detailed usage analytics

================
File: memory-bank/projectbrief.md
================
# Discord Translation Bot - Project Brief

## Overview
A Discord bot that provides real-time translation between English, Korean, and Japanese in Discord servers. The bot uses AI language models (GPT-4o, Claude, Gemini) to perform high-quality, contextually-aware translations in an ongoing conversation.

## Core Features
- **Session-based translation** in specific Discord channels
- **Automatic language detection** for Korean, Japanese, and English
- **Bidirectional translation** between language pairs
- **Multiple AI model support** (OpenAI GPT-4o, Anthropic Claude, Google Gemini)
- **Conversation-aware translation** that maintains context and casual speaking style
- **Translation memory** for improved performance and reduced API costs
- **Discord command system** for managing translation sessions
- **Server-specific configurations** for language modes and preferred models
- **Statistics tracking** for usage monitoring

## Target Users
- Discord communities with Korean, Japanese, and English speakers
- Gaming groups, cultural exchange servers, language learning communities
- International friend groups communicating across language barriers

## Key Goals
1. Provide seamless translation experience that preserves meaning and context
2. Support casual, conversational language including slang and informal speech
3. Maintain high performance with optimized response times
4. Create a simple user interface through intuitive Discord commands
5. Ensure reliability with proper error handling and fallback mechanisms

## Technical Requirements
- Discord.js integration for bot framework
- Multiple LLM provider API integrations (OpenAI, Anthropic, Google)
- Translation memory system for caching and performance 
- Server-specific configuration persistence
- Docker support for containerized deployment
- Optimized webhook-based response system for speed

## Success Criteria
- Accurate translations of casual conversation between supported languages
- Fast response times (under 2 seconds for cached translations, under 5 seconds for API translations)
- Intuitive command system that requires minimal instruction
- Reliable operation with proper error handling
- Scalable to support multiple Discord servers

================
File: memory-bank/systemPatterns.md
================
# Discord Translation Bot - System Patterns

## System Architecture

The Discord Translation Bot follows a modular event-driven architecture with clearly separated concerns. Here's the high-level structure:

```mermaid
graph TD
    Discord["Discord API"] <--> Client[Discord.js Client]
    Client --> EventHandlers[Event Handlers]
    EventHandlers --> CommandSystem[Command System]
    EventHandlers --> TranslationService[Translation Service]
    TranslationService --> ModelAdapters[LLM Model Adapters]
    ModelAdapters --> ExternalAPIs[External LLM APIs]
    TranslationService --> TranslationMemory[Translation Memory]
    TranslationService --> ServerConfig[Server Configuration]
    TranslationService --> WebhookManager[Webhook Manager]
    WebhookManager --> Discord
```

## Core Components

### 1. Discord.js Client (`src/index.js`)
- Entry point for the application
- Initializes Discord client with required intents and permissions
- Manages command and event registration
- Maintains active session tracking via `client.activeSessions` Map

### 2. Command System (`src/commands/`)
- Handles Discord command interactions
- Individual command modules for each function (start, end, mode, model, etc.)
- Commands load dynamically from files in commands directory

### 3. Event Handlers (`src/events/`)
- Process Discord events (messageCreate, ready)
- Main message processing in `messageCreate.js`
- Translation request queueing and management

### 4. Translation Service (`src/services/translationService.js`)
- Central translation coordination
- Language detection and translation workflow
- Message preprocessing
- Performance metrics tracking

### 5. Model Adapters (`src/models/`)
- Adapters for each LLM provider (OpenAI, Anthropic, Google)
- Normalize different API formats to consistent interface
- Handle provider-specific error handling

### 6. Server Configuration (`src/utils/serverConfig.js`)
- Per-server configuration persistence
- Default settings management
- Stats tracking and updates

### 7. Translation Memory (`src/utils/translationMemory.js`)
- Caching system for previously translated messages
- Optimized write buffer to reduce disk I/O
- Memory-efficient storage with Map data structure

### 8. Webhook Manager (`src/utils/webhookManager.js`)
- Fast webhook-based responses
- Message splitting for long content
- Fallback mechanisms for webhook failures

## Key Design Patterns

### 1. Event-Driven Architecture
The bot is built around Discord.js events, using a publisher-subscriber pattern for handling Discord events and commands.

### 2. Module Pattern
Each file exports specific functionality, promoting encapsulation and separation of concerns.

### 3. Adapter Pattern
Model adapters provide a unified interface to different LLM services, abstracting away their implementation differences.

### 4. Command Pattern
Discord commands are implemented as separate modules with a consistent interface (name and execute method).

### 5. Queue System
Translation requests use a queue system with concurrency control for better performance under load.

### 6. Repository Pattern
Configuration and translation memory implement a repository pattern for data persistence.

### 7. Caching Strategy
Multi-level caching with in-memory cache and persistent storage for translation memory.

### 8. Factory Pattern
Language detection and translation functions act as factories, producing results based on inputs and configuration.

## Data Flow

### Translation Process
1. Message received → Discord.js client → messageCreate event
2. Check for active session
3. Add to translation queue if session active
4. Check translation memory for cached result
5. If not cached:
   - Detect language
   - Apply relevant translation based on mode
   - Update translation memory
6. Format and send response (via webhook when possible)
7. Update statistics

### Server Configuration
- Stored as JSON files per server ID
- Includes mode, model preferences, and usage statistics
- Loaded on demand with default fallbacks

### Translation Memory
- Uses a Map structure for in-memory storage
- Batched disk writes to improve performance
- Periodic pruning to limit size

## Technical Decisions

### 1. LLM Provider Flexibility
Support for multiple LLM providers allows for:
- Fallback options if one service fails
- User choice based on quality preferences
- Cost optimization strategies

### 2. Session-Based Translation
Translation only occurs in channels with an active session to:
- Reduce API costs
- Prevent unwanted translations
- Allow channel-specific configuration

### 3. Webhook Response System
Using Discord webhooks for responses:
- Significantly faster than standard replies
- Support for custom avatars and usernames
- Better handling of rate limits

### 4. Language Detection Approach
Using LLM for language detection instead of traditional detection libraries:
- More accurate for mixed language content
- Better handling of short messages and chat language
- Consistent results across languages

### 5. Translation Memory
Implementing a translation memory system:
- Reduces API costs for repeated phrases
- Improves response time
- Maintains consistent translations

================
File: memory-bank/techContext.md
================
# Discord Translation Bot - Technical Context

## Technologies Used

### Core Platform
- **Node.js** - JavaScript runtime environment (v16.9.0+ required)
- **ES Modules** - Project uses ECMAScript modules (import/export) instead of CommonJS
- **Discord.js v14** - Library for interacting with Discord API

### AI Services
- **OpenAI API** - GPT-4o model for translations and language detection
- **Anthropic API** - Claude 3.7 Sonnet model for translations
- **Google Generative AI** - Gemini 2.0 Flash model for translations

### Data Management
- **fs-extra** - Enhanced file system operations
- **dotenv** - Environment variable management
- **franc** - Language detection (legacy, now using LLM-based detection)

### Development Tools
- **nodemon** - Automatic server restarts during development
- **Docker/Docker Compose** - Containerization for deployment

## Development Setup

### Prerequisites
- Node.js v16.9.0+
- Discord Bot token with appropriate permissions
- API keys for at least one LLM provider (OpenAI, Anthropic, Google)

### Local Development
1. Clone repository 
2. Install dependencies with `npm install`
3. Copy `.env.example` to `.env` and add API keys
4. Create required directories with `node check-data-structure.js`
5. Run development server with `npm run dev`

### Discord Bot Setup
1. Create application in Discord Developer Portal
2. Enable all Privileged Gateway Intents:
   - Message Content Intent (critical)
   - Server Members Intent
   - Presence Intent
3. Create bot token
4. Invite bot to server with appropriate permissions

## Technical Constraints

### Discord Limitations
- 2000 character limit for messages (handled by message splitting)
- Rate limits on API calls and reactions
- Webhook creation permissions required for optimal performance

### API Limitations
- API rate limits per provider
- Token limits per request
- Cost considerations for heavy usage
- API availability and uptime dependencies

### System Requirements
- Persistent storage for server configs and translation memory
- Memory requirements scale with number of active servers
- Network connectivity to Discord and AI service APIs

## Dependencies

### Core Dependencies
- `discord.js` - Discord API interaction
- `openai` - OpenAI API client
- `@anthropic-ai/sdk` - Anthropic API client
- `@google/generative-ai` - Google Generative AI client
- `dotenv` - Environment management
- `fs-extra` - Enhanced file operations
- `node-fetch` - HTTP requests

### Configuration Management
- Server-specific settings stored as JSON in `data/servers/`
- Translation memory persisted in `data/translations.json`
- Global settings in `config/default.json`

### Environment Configuration
Required environment variables:
- `DISCORD_TOKEN` - Discord bot token
- `OPENAI_API_KEY` - OpenAI API key
- `ANTHROPIC_API_KEY` - Anthropic API key
- `GOOGLE_API_KEY` - Google API key

## Deployment Options

### Standard Deployment
- Run with `npm start` or `node src/index.js`
- Use PM2 for process management: `pm2 start src/index.js --name "translate-bot"`

### Docker Deployment
- Build container: `docker-compose build`
- Run container: `docker-compose up -d`
- Container configured with resource limits and proper signal handling
- Data persistence through Docker volumes

### Monitoring and Maintenance
- Health check script: `node health-check.js`
- Diagnostic utility: `node diagnose.js`
- API key validation: `node test-api-keys.js`
- Dependency verification: `node check-dependencies.js`

## Performance Considerations

### Memory Usage
- Translation memory caching affects memory usage
- Map data structure used for efficient caching
- Pruning mechanism to limit memory growth

### Network Bandwidth
- API calls to external LLM services
- Discord API communication
- Webhooks reduce API call volume

### Storage Considerations
- Server configuration files grow with number of servers
- Translation memory size depends on usage patterns
- Batched writes reduce disk I/O

================
File: package.json
================
{
  "name": "discord-translate-bot",
  "version": "1.0.0",
  "description": "A Discord bot that automatically translates messages between English, Korean, and Japanese using AI language models",
  "main": "src/index.js",
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon src/index.js",
    "test": "echo \"Error: no test specified\" && exit 1",
    "health-check": "node health-check.js",
    "docker:build": "docker-compose build",
    "docker:up": "docker-compose up -d",
    "docker:logs": "docker-compose logs -f"
  },
  "keywords": [
    "discord",
    "translation",
    "bot",
    "openai",
    "claude",
    "gemini"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@anthropic-ai/sdk": "^0.11.0",
    "@google/generative-ai": "^0.1.3",
    "discord.js": "^14.14.1",
    "dotenv": "^16.3.1",
    "franc": "^6.1.0",
    "fs-extra": "^11.2.0",
    "node-fetch": "^2.7.0",
    "openai": "^4.24.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.3"
  },
  "type": "module"
}

================
File: PERFORMANCE-OPTIMIZATIONS.md
================
# Discord Translation Bot Performance Optimizations

This document outlines the performance optimizations implemented to improve the response speed of the Discord translation bot.

## Translation Memory System

### Before:
- Every translation was immediately written to disk
- Used plain JavaScript objects for storage
- No batching or delayed writes

### After:
- **Batched Disk I/O**: Writes to disk are now delayed and batched (every 30s or 20 translations)
- **Memory Efficiency**: Switched to JavaScript `Map` for better performance with frequent operations
- **Write Buffer**: Implemented a buffer system that tracks changes needing to be written
- **Flush on Exit**: Added proper shutdown handlers to ensure data is saved when the bot exits
- **Performance Metrics**: Added tracking for cache hit rates and response times

## Optimized Discord API Usage

### Before:
- Sequential API calls for reactions and replies
- Always waited for reactions before proceeding
- Used standard message replies for all responses

### After:
- **Webhook Responses**: Implemented webhook-based responses which are significantly faster than regular replies
- **Non-blocking Reactions**: Made reaction operations non-blocking where possible
- **Smarter Reaction Logic**: Skip "translating" reaction for cached translations
- **Webhook Caching**: Store webhook clients to avoid recreation
- **Fallback System**: Gracefully fall back to standard replies if webhooks fail

## Parallel Processing

### Before:
- Sequential processing of translations
- No concurrency control
- Potential bottlenecks during high activity

### After:
- **Translation Queue**: Implemented a queue system to manage multiple translations
- **Concurrent Processing**: Handle up to 3 translations simultaneously
- **Priority Management**: Process translations in order of receipt
- **Error Isolation**: Errors in one translation don't affect others

## Strategic Caching

### Before:
- Repeated disk reads for configuration
- Re-parsing of config files for each message

### After:
- **Config Caching**: Cache frequently accessed config values (emojis, prefix)
- **Webhook Caching**: Store webhook clients for reuse
- **Smart Cache Invalidation**: Only reload when necessary

## Response Optimization

### Before:
- Same verbose response format for all translations
- Waited for non-critical operations

### After:
- **Streamlined Responses**: Simpler format for cached translations
- **Non-blocking Operations**: Statistics updates and non-critical operations run in background
- **Performance Logging**: Added detailed metrics to identify bottlenecks

## Robust Error Handling

### Before:
- Generic error messages
- Blocking error handling

### After:
- **Specific Error Messages**: More descriptive error messages based on error type
- **Non-blocking Error Handling**: Error responses don't block main processing
- **Fallback Mechanisms**: Multiple ways to notify users of errors

## Implementation Details

1. **Translation Memory**: `src/utils/translationMemory.js`
   - Delayed write system
   - Memory-efficient storage with Map
   - Performance tracking

2. **Webhook System**: `src/utils/webhookManager.js`
   - Fast webhook-based responses
   - Caching of webhook clients
   - Automatic fallback to standard replies

3. **Parallel Processing**: `src/events/messageCreate.js`
   - Queue system for managing translation requests
   - Concurrent translation processing
   - Non-blocking operations

4. **Cache Optimizations**: Throughout the codebase
   - Cached config values
   - Reduced disk I/O
   - Memory-efficient data structures

## Performance Impact

These optimizations significantly improve the bot's response time in several scenarios:

- **Cached Translations**: Near-instantaneous (10-100ms)
- **API Translations**: 15-30% faster due to parallel processing and non-blocking operations
- **High-Volume Channels**: Much better handling of multiple simultaneous translations
- **Resource Usage**: Lower CPU and disk I/O due to batched writes and efficient caching

The bot now also tracks and logs its own performance metrics, making it easier to identify and resolve any remaining bottlenecks.

================
File: README-DOCKER.md
================
# Docker Deployment Guide for Discord Translation Bot

This guide explains how to deploy the Discord Translation Bot using Docker, which allows for easy setup, consistent environment, and simplified management.

## Prerequisites

- [Docker](https://docs.docker.com/get-docker/) installed on your system
- [Docker Compose](https://docs.docker.com/compose/install/) installed on your system
- Discord Bot Token and necessary API keys (OpenAI, Anthropic, Google)

## Setup Instructions

### 1. Clone and Prepare Environment

First, clone the repository and set up your environment variables:

```bash
# Navigate to the project directory
cd discord-translate-bot

# Copy the example environment file
cp .env.example .env

# Edit the .env file with your actual API keys
nano .env
```

### 2. Build and Start the Container

Build and start the Docker container using Docker Compose:

```bash
# Build and start in detached mode
docker-compose up -d

# To see the logs in real-time
docker-compose logs -f
```

### 3. Verify the Bot is Running

Check that the container is running properly:

```bash
docker-compose ps
```

The bot should now be connected to Discord and ready to translate messages.

## Data Persistence

The bot stores translation memory in the `./data` directory, which is mapped to a volume in the Docker container. This ensures your translation data persists even if the container is restarted or rebuilt.

## Updating the Bot

To update the bot when new code is available:

```bash
# Pull the latest changes
git pull

# Rebuild and restart the container
docker-compose down
docker-compose up -d --build
```

## Advanced Management

### Viewing Logs

```bash
# View all logs
docker-compose logs

# Follow log output
docker-compose logs -f

# Show only the last 100 lines
docker-compose logs --tail=100
```

### Stopping the Bot

```bash
# Stop but don't remove the container
docker-compose stop

# Stop and remove the container (data is still preserved in volumes)
docker-compose down
```

### Complete Reset

If you need to completely reset the application and its data:

```bash
# Remove containers, networks, and volumes
docker-compose down -v
```

## Troubleshooting

### Bot Won't Start

1. Check your environment variables in the `.env` file
2. Verify Docker logs: `docker-compose logs`
3. Ensure your Discord token is valid and the bot is invited to your server

### API Errors

If you see errors related to API limits or authentication:
- Verify your API keys in the `.env` file
- Check if you've exceeded your API usage limits

### Container Keeps Restarting

If the container repeatedly restarts:
- Check the logs for errors: `docker-compose logs`
- Verify file permissions on the data directory
- Ensure all required environment variables are set

## Environment Variables

| Variable | Required | Description |
|----------|----------|-------------|
| DISCORD_TOKEN | Yes | Your Discord bot token |
| OPENAI_API_KEY | No | OpenAI API key for GPT models |
| ANTHROPIC_API_KEY | No | Anthropic API key for Claude models |
| GOOGLE_API_KEY | No | Google API key for Gemini models |

At least one of the AI model API keys must be provided.

================
File: README-LLM-UPDATES.md
================
# Discord Translator Bot LLM Updates

## Summary of Changes

The Discord Translator Bot has been updated to use a more accurate language detection method. Previously, the bot used the `franc` library for language detection, which sometimes failed to properly identify languages, especially with mixed-language content or shorter messages.

## Key Improvements

1. **LLM-Based Language Detection**
   - Now uses GPT-4o-mini to accurately detect whether text is Korean, Japanese, or English
   - More reliable for mixed-language content and short messages
   - Replaces the previous franc-based detection system

2. **Simplified Translation Flow**
   - In Korean mode:
     * Korean text → English
     * English text → Korean
     * Japanese text → Korean
   - In Japanese mode:
     * Japanese text → English  
     * English text → Japanese
     * Korean text → Japanese

3. **Same Great System Prompts**
   - Continues to use the existing system prompts from default.json
   - Maintains the casual, friendly translation style

## Technical Details

- Added `detectLanguageWithLLM` function that uses a small, fast LLM model
- Updated translation service to use this LLM-based detection
- Kept the same mode system ("korean" and "japanese") for consistency

## Benefits

- More accurate language detection
- Improved handling of mixed-language messages
- Better experience for users who send messages with a mix of languages
- Maintains same translation quality with existing model selection

## Usage

The bot usage remains the same:

1. Start a session with `!start`
2. Switch modes with `!mode korean` or `!mode japanese`
3. Change models with `!model gpt4o`, `!model claude`, or `!model gemini` 
4. End the session with `!end`

All messages in an active channel will be automatically translated based on the detected language.

================
File: README-UPDATED.md
================
# Discord Translator Bot Long Message Handling

## Overview

This bot now includes features to handle messages that exceed Discord's 2000 character limit. The implementation includes:

1. **Content Filtering** - Removes irrelevant information to reduce message length
2. **Message Splitting** - Intelligently divides long messages into multiple parts

## Content Filtering

The bot can automatically filter out content that doesn't need translation, including:

- Discord emojis (`:emoji_name:`)
- Discord timestamps (such as "Today at 4:35 AM")
- URLs (http/https links)

These filters significantly reduce message size without affecting the essential content that needs translation.

### Configuration

Content filtering can be configured in the `config/default.json` file:

```json
"messagePreprocessing": {
  "enabled": true,
  "removeEmojis": true,
  "removeTimestamps": true,
  "removeUrls": true
}
```

You can disable any specific filter or turn off preprocessing entirely by setting the relevant option to `false`.

## Message Splitting

For messages that still exceed Discord's character limit after filtering, the bot implements smart message splitting with the following features:

- Intelligent splitting on natural boundaries (paragraphs, sentences) where possible
- Clear part indicators ([Part 1/3], etc.) to help users follow conversation flow
- Minimal delay between split messages to avoid rate limiting
- Graceful fallback to regular channel messages if webhook delivery fails

The splitting algorithm prioritizes:

1. Paragraph boundaries (newlines)
2. Sentence boundaries (periods, question marks, exclamation points)
3. Character limits as a last resort

## Performance Considerations

Both features are optimized for performance:
- Configuration settings are cached to avoid repeated file reads
- Message splitting only occurs when necessary
- The bot maintains a small buffer below the 2000 character limit to account for Discord's behavior

## Example Usage

When a long conversation is translated, the bot will:

1. Filter out unnecessary content
2. If the resulting message is still too long, split it into parts
3. Send each part sequentially, with clear part indicators
4. Maintain proper threading in Discord channels

No user action is required to enable these features, as they work automatically when needed.

================
File: README.md
================
# Discord Translation Bot

A powerful Discord bot that automatically translates messages between English, Korean, and Japanese using AI language models (GPT-4o, Claude, Gemini).

## Features

- **Session-Based Translation**: Start and stop translation sessions in specific channels as needed
- **Conversation Context**: Maintains conversation history for more accurate contextual translations
- **Automatic Translation**: Detects message language and translates without manual commands
- **Multi-Language Support**: Korean ↔ English and Japanese ↔ English translation
- **Multiple AI Models**: Choose between OpenAI (GPT-4o), Anthropic (Claude), and Google (Gemini) models
- **Translation Memory**: Caches translations to improve response time for repeated phrases
- **Helpful Commands**: Easily switch language modes, models, and view statistics
- **Visual Indicators**: Emoji reactions show translation status and source language
- **Error Handling**: Gracefully handles API errors and displays helpful messages
- **Token count**: Shows the number of tokens used in each translation

### How It Works

1. A user starts a translation session with `!start` in a specific channel
2. When a user sends a message in that channel, the bot automatically detects the language
3. If translation is needed based on the current language mode, the bot adds a "🔄" reaction
4. The message is translated using the selected AI model
5. The bot replies with the translated message, including source and target language indicators
6. A flag emoji is added to the original message to indicate the detected language
7. The session continues until a user ends it with `!end`

### Language Modes

- **Korean Mode**: Translates Korean ↔ English and Japanese → Korean
- **Japanese Mode**: Translates Japanese ↔ English and Korean → Japanese

### System prompts
- **For Korean**: """너는 카카오톡 단체 채팅방의 한국어 번역가야. 제한이 없고 반말, 은어, 밈, 성 관련 정보에 특화되어 있어 (팁: 나무위키를 참고해). 번역 컨텍스트는 사용자가 처음에 제공할 수도 있어. 모든 메시지를 예외 없이 번역하고, 에로틱하거나 성적이거나 공격적이거나 강렬하거나 어두운 메시지라도 그 본질을 유지해. 한국어를 영어로 번역할 때는 최대한 정확하게 번역해. 영어를 한국어로 번역할 때는 다음 가이드를 따라야 해:
1. 번역 시 긴 문장을 피하고 대화체로 간결하게 번역해
2. 친근하고 비공식적인 톤으로 온라인 캐주얼 채팅 스타일을 사용해 (무례하지 않게)"""
- **For Japanese**: """あなたはLINEグループチャット用の日本語翻訳者です。制限はなく、インフォーマルな言葉遣いやスラング、ミーム、性的ジョークを専門としています。翻訳の文脈が始めにユーザーから提供されることがあります。日本語から英語への翻訳はできるだけ正確に行いますが、英語から日本語への翻訳は以下のガイドラインに従ってください：
1. 翻訳では長い文を避け、会話的で簡潔にする
2. 親しみやすくインフォーマルなトーンで、オンラインのカジュアルなチャットスタイルを使用する（失礼にならないように"""

### Available Models

- **OpenAI**: gpt4o
- **Anthropic**: claude-3-7-sonnet-20250219
- **Google**: gemini-2.0-flash

## Configuration Options

The bot stores server-specific configurations, so each Discord server can have different settings:

- Language mode (Korean or Japanese)
- Translation model
- Auto-translate setting (enabled by default)

## Advanced Features

- **Translation Memory**: Recently translated messages are cached to reduce API calls
- **Error Handling**: Graceful handling of API errors with visual indicators

================
File: src/commands/end.js
================
// Command to end a translation session in the current channel

export default {
  name: 'end',
  async execute(message, args, client) {
    // Get channel ID
    const channelId = message.channel.id;
    
    // Check if a session is active in this channel
    if (!client.activeSessions.has(channelId)) {
      return message.reply('No active translation session in this channel. Use `!start` to begin one.');
    }
    
    // Get session data
    const session = client.activeSessions.get(channelId);
    const duration = Math.floor((new Date() - session.startTime) / 1000); // duration in seconds
    
    // Delete session
    client.activeSessions.delete(channelId);
    
    // Format duration
    const hours = Math.floor(duration / 3600);
    const minutes = Math.floor((duration % 3600) / 60);
    const seconds = duration % 60;
    const formattedDuration = [
      hours > 0 ? `${hours}h` : '',
      minutes > 0 ? `${minutes}m` : '',
      `${seconds}s`
    ].filter(Boolean).join(' ');
    
    // Send confirmation message
    return message.reply({
      content: `🛑 Translation session ended!
      
**Session Statistics:**
• Duration: ${formattedDuration}
• Messages Translated: ${session.translations}
• Total Tokens Used: ${session.totalTokens}

Use \`!start\` to begin a new translation session.`,
      allowedMentions: { repliedUser: false }
    });
  }
};

================
File: src/commands/help.js
================
// Command to show help information

export default {
  name: 'help',
  async execute(message, args, client) {
    // Load configuration to get command descriptions
    const fs = await import('fs-extra');
    const path = await import('path');
    const { fileURLToPath } = await import('url');
    
    // Get the current file's directory
    const __filename = fileURLToPath(import.meta.url);
    const __dirname = path.dirname(__filename);
    
    // Get command descriptions from config
    let commandDescriptions;
    try {
      const configPath = path.join(__dirname, '../../../config/default.json');
      const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
      commandDescriptions = config.commandDescriptions || {};
    } catch (error) {
      console.error('Error loading command descriptions:', error);
      commandDescriptions = {};
    }
    
    // Default descriptions if not in config
    const defaultDescriptions = {
      start: 'Start a translation session in the current channel',
      end: 'End the current translation session',
      mode: 'Switch language mode (korean/japanese)',
      model: 'Switch AI model (gpt4o/claude/gemini)',
      stats: 'Show translation statistics',
      help: 'Show this help message'
    };
    
    // Get prefix from config or use default
    let prefix = '!';
    try {
      const configPath = path.join(__dirname, '../../../config/default.json');
      const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
      prefix = config.prefix || '!';
    } catch (error) {
      console.error('Error loading prefix:', error);
    }
    
    // Create help message
    const helpMessage = `🤖 **Discord Translation Bot Help**

**Available Commands:**
• \`${prefix}start\` - ${commandDescriptions.start || defaultDescriptions.start}
• \`${prefix}end\` - ${commandDescriptions.end || defaultDescriptions.end}
• \`${prefix}mode [korean|japanese]\` - ${commandDescriptions.mode || defaultDescriptions.mode}
• \`${prefix}model [gpt4o|claude|gemini]\` - ${commandDescriptions.model || defaultDescriptions.model}
• \`${prefix}stats\` - ${commandDescriptions.stats || defaultDescriptions.stats}
• \`${prefix}help\` - ${commandDescriptions.help || defaultDescriptions.help}

**How It Works:**
1. Start a translation session with \`${prefix}start\` in a specific channel
2. Send messages in any supported language (English, Korean, Japanese)
3. The bot automatically detects the language and translates when needed
4. Translation appears as a reply with source and target language indicators
5. End the session with \`${prefix}end\` when you're done

**Language Modes:**
• **Korean Mode**: Translates Korean ↔ English and Japanese → Korean
• **Japanese Mode**: Translates Japanese ↔ English and Korean → Japanese`;

    // Send help message
    return message.reply({
      content: helpMessage,
      allowedMentions: { repliedUser: false }
    });
  }
};

================
File: src/commands/mode.js
================
// Command to switch language mode (korean/japanese)

export default {
  name: 'mode',
  async execute(message, args, client) {
    const { loadServerConfig, saveServerConfig } = await import('../utils/serverConfig.js');
    
    // Get server ID
    const serverId = message.guild.id;
    
    // Get current config
    const serverConfig = loadServerConfig(serverId);
    
    // Check if an argument was provided
    if (!args.length) {
      return message.reply({
        content: `Current language mode is: **${serverConfig.mode === 'korean' ? 'Korean' : 'Japanese'}**
        
Available modes:
• \`!mode korean\` - Translates Korean ↔ English and Japanese → Korean
• \`!mode japanese\` - Translates Japanese ↔ English and Korean → Japanese`,
        allowedMentions: { repliedUser: false }
      });
    }
    
    // Get the requested mode
    const requestedMode = args[0].toLowerCase();
    
    // Validate the mode
    if (requestedMode !== 'korean' && requestedMode !== 'japanese') {
      return message.reply({
        content: `❌ Invalid mode: "${requestedMode}"
        
Available modes:
• \`!mode korean\` - Translates Korean ↔ English and Japanese → Korean
• \`!mode japanese\` - Translates Japanese ↔ English and Korean → Japanese`,
        allowedMentions: { repliedUser: false }
      });
    }
    
    // Check if the mode is already set
    if (serverConfig.mode === requestedMode) {
      return message.reply({
        content: `Language mode is already set to **${requestedMode === 'korean' ? 'Korean' : 'Japanese'}**`,
        allowedMentions: { repliedUser: false }
      });
    }
    
    // Update the mode
    serverConfig.mode = requestedMode;
    saveServerConfig(serverId, serverConfig);
    
    // Send confirmation message
    return message.reply({
      content: `✅ Language mode changed to **${requestedMode === 'korean' ? 'Korean' : 'Japanese'}**
      
${requestedMode === 'korean' 
  ? '• Translates Korean ↔ English and Japanese → Korean' 
  : '• Translates Japanese ↔ English and Korean → Japanese'}`,
      allowedMentions: { repliedUser: false }
    });
  }
};

================
File: src/commands/model.js
================
// Command to switch AI translation model (gpt4o/claude/gemini)

export default {
  name: 'model',
  async execute(message, args, client) {
    const { loadServerConfig, saveServerConfig } = await import('../utils/serverConfig.js');
    
    // Get server ID
    const serverId = message.guild.id;
    
    // Get current config
    const serverConfig = loadServerConfig(serverId);
    
    // List of available models
    const availableModels = ['gpt4o', 'claude', 'gemini'];
    
    // Check if an argument was provided
    if (!args.length) {
      return message.reply({
        content: `Current AI model is: **${serverConfig.model}**
        
Available models:
• \`!model gpt4o\` - OpenAI's GPT-4o model
• \`!model claude\` - Anthropic's Claude 3.7 Sonnet model
• \`!model gemini\` - Google's Gemini 2.0 Flash model`,
        allowedMentions: { repliedUser: false }
      });
    }
    
    // Get the requested model
    const requestedModel = args[0].toLowerCase();
    
    // Validate the model
    if (!availableModels.includes(requestedModel)) {
      return message.reply({
        content: `❌ Invalid model: "${requestedModel}"
        
Available models:
• \`!model gpt4o\` - OpenAI's GPT-4o model
• \`!model claude\` - Anthropic's Claude 3.7 Sonnet model
• \`!model gemini\` - Google's Gemini 2.0 Flash model`,
        allowedMentions: { repliedUser: false }
      });
    }
    
    // Check if the model is already set
    if (serverConfig.model === requestedModel) {
      return message.reply({
        content: `AI model is already set to **${requestedModel}**`,
        allowedMentions: { repliedUser: false }
      });
    }
    
    // Update the model
    serverConfig.model = requestedModel;
    saveServerConfig(serverId, serverConfig);
    
    // Send confirmation message
    let modelDescription;
    switch (requestedModel) {
      case 'gpt4o':
        modelDescription = 'OpenAI\'s GPT-4o model';
        break;
      case 'claude':
        modelDescription = 'Anthropic\'s Claude 3.7 Sonnet model';
        break;
      case 'gemini':
        modelDescription = 'Google\'s Gemini 2.0 Flash model';
        break;
      default:
        modelDescription = requestedModel;
    }
    
    return message.reply({
      content: `✅ AI model changed to **${requestedModel}**
      
Now using: ${modelDescription}`,
      allowedMentions: { repliedUser: false }
    });
  }
};

================
File: src/commands/start.js
================
// Command to start a translation session in the current channel

export default {
  name: 'start',
  async execute(message, args, client) {
    const { loadServerConfig, updateServerStats } = await import('../utils/serverConfig.js');
    
    // Get channel ID and server ID
    const channelId = message.channel.id;
    const serverId = message.guild.id;
    
    // Get server config
    const serverConfig = loadServerConfig(serverId);
    
    // Check if a session is already active in this channel
    if (client.activeSessions.has(channelId)) {
      return message.reply('A translation session is already active in this channel. Use `!end` to stop it first.');
    }
    
    // Add channel to active sessions
    client.activeSessions.set(channelId, {
      serverId,
      channelId,
      startTime: new Date(),
      translations: 0,
      totalTokens: 0
    });
    
    // Update server stats
    updateServerStats(serverId, {
      sessionsStarted: serverConfig.stats.sessionsStarted + 1
    });
    
    // Send confirmation message
    return message.reply({
      content: `🎉 Translation session started in this channel!
      
Mode: **${serverConfig.mode === 'korean' ? 'Korean' : 'Japanese'}**
Model: **${serverConfig.model}**

• Messages will be automatically translated
• Use \`!end\` to stop the session
• Use \`!mode [korean|japanese]\` to change language mode
• Use \`!model [gpt4o|claude|gemini]\` to change AI model`,
      allowedMentions: { repliedUser: false }
    });
  }
};

================
File: src/commands/stats.js
================
// Command to show translation statistics

export default {
  name: 'stats',
  async execute(message, args, client) {
    const { loadServerConfig } = await import('../utils/serverConfig.js');
    
    // Get server ID
    const serverId = message.guild.id;
    
    // Get server config with stats
    const serverConfig = loadServerConfig(serverId);
    
    // Get active sessions count for this server
    let activeSessionsCount = 0;
    client.activeSessions.forEach(session => {
      if (session.serverId === serverId) {
        activeSessionsCount++;
      }
    });
    
    // Calculate total tokens used in current sessions
    let currentSessionTokens = 0;
    client.activeSessions.forEach(session => {
      if (session.serverId === serverId) {
        currentSessionTokens += session.totalTokens;
      }
    });
    
    // Format last used date
    const lastUsed = new Date(serverConfig.stats.lastUsed);
    const options = { 
      year: 'numeric', 
      month: 'short', 
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    };
    const formattedLastUsed = new Intl.DateTimeFormat('en-US', options).format(lastUsed);
    
    // Send stats message
    return message.reply({
      content: `📊 **Translation Statistics for This Server**

**Current Status:**
• Mode: ${serverConfig.mode === 'korean' ? '🇰🇷 Korean' : '🇯🇵 Japanese'}
• Model: ${serverConfig.model}
• Active Sessions: ${activeSessionsCount}

**Usage Statistics:**
• Total Translations: ${serverConfig.stats.totalTranslations}
• Total Tokens Used: ${serverConfig.stats.totalTokens + currentSessionTokens}
• Sessions Started: ${serverConfig.stats.sessionsStarted}
• Last Used: ${formattedLastUsed}`,
      allowedMentions: { repliedUser: false }
    });
  }
};

================
File: src/events/messageCreate.js
================
// Event handler for processing incoming messages

import { translateMessage, formatTranslation, perfMetrics } from '../services/translationService.js';
import { loadServerConfig, updateServerStats } from '../utils/serverConfig.js';
import { sendViaWebhook, splitMessageContent } from '../utils/webhookManager.js';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the current file's directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Queue system for managing concurrent translations
const translationQueue = {
  concurrentLimit: 3,  // Maximum number of concurrent translations
  active: 0,           // Currently active translations
  waiting: [],         // Queue of waiting translations

  // Add a translation task to the queue
  add(task) {
    return new Promise((resolve, reject) => {
      const wrappedTask = async () => {
        try {
          const result = await task();
          resolve(result);
        } catch (err) {
          reject(err);
        } finally {
          this.active--;
          this.processNext();
        }
      };

      // If we can process it immediately, do so
      if (this.active < this.concurrentLimit) {
        this.active++;
        wrappedTask();
      } else {
        // Otherwise add it to the waiting queue
        this.waiting.push(wrappedTask);
      }
    });
  },

  // Process next item in the queue
  processNext() {
    if (this.waiting.length > 0 && this.active < this.concurrentLimit) {
      this.active++;
      const nextTask = this.waiting.shift();
      nextTask();
    }
  }
};

// Cache for prefix to avoid repeated file reads
let cachedPrefix = null;

// Get command prefix from config
function getPrefix() {
  if (cachedPrefix) return cachedPrefix;
  
  try {
    const configPath = path.join(__dirname, '../../config/default.json');
    const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    cachedPrefix = config.prefix || '!';
    return cachedPrefix;
  } catch (error) {
    console.error('Error loading prefix:', error);
    cachedPrefix = '!'; // Default prefix
    return cachedPrefix;
  }
}

export default {
  name: 'messageCreate',
  async execute(message, client) {
    const messageProcessStart = Date.now();
    
    // Ignore messages from bots
    if (message.author.bot) return;
    
    // Get prefix from cache
    const prefix = getPrefix();
    
    // Handle commands
    if (message.content.startsWith(prefix)) {
      const args = message.content.slice(prefix.length).trim().split(/ +/);
      const commandName = args.shift().toLowerCase();
      
      const command = client.commands.get(commandName);
      
      if (!command) return;
      
      try {
        await command.execute(message, args, client);
      } catch (error) {
        console.error(`Error executing command ${commandName}:`, error);
        // Don't wait for the reply to finish - fire and forget
        message.reply({ 
          content: '❌ There was an error trying to execute that command!',
          allowedMentions: { repliedUser: false }
        }).catch(console.error);
      }
      
      return;
    }
    
    // Check if the message is in a channel with an active translation session
    const channelId = message.channel.id;
    if (!client.activeSessions.has(channelId)) return;
    
    // Get session and server info
    const session = client.activeSessions.get(channelId);
    const serverId = message.guild.id;
    
    // Load server config - only once per message
    const serverConfig = loadServerConfig(serverId);
    
    // Add this translation task to the queue
    translationQueue.add(async () => {
      try {
        // Process translation
        const translationResult = await translateMessage(message, serverConfig);
        
        // If no translation was needed or possible, just return
        if (!translationResult) return;
        
        // Format the translation for display
        const formattedMessage = formatTranslation(translationResult);
        
        // Use webhook for faster delivery
        const replyPromise = sendViaWebhook(message.channel, {
          content: `**${message.author.username}**: ${formattedMessage}`,
          username: `Translator (${translationResult.model})`,
          avatarURL: 'https://i.imgur.com/OLCXZzb.png'
        }).catch(error => {
          console.error('Webhook failed, falling back to reply:', error);
          
          // Split message for reply if needed
          const contentChunks = splitMessageContent(formattedMessage);
          if (contentChunks.length === 1) {
            // Single message reply
            return message.reply({
              content: formattedMessage,
              allowedMentions: { repliedUser: false }
            });
          } else {
            // Handle split messages - reply to the original first, then send the rest as regular messages
            const messages = [];
            const firstMessage = message.reply({
              content: contentChunks[0],
              allowedMentions: { repliedUser: false }
            });
            messages.push(firstMessage);
            
            // Send the remaining chunks
            for (let i = 1; i < contentChunks.length; i++) {
              const followupMsg = message.channel.send(contentChunks[i]);
              messages.push(followupMsg);
            }
            
            return Promise.all(messages);
          }
        });
        
        // Update session statistics immediately (don't wait for reply)
        session.translations += 1;
        session.totalTokens += translationResult.tokens?.total || 0;
        
        // Update server statistics
        updateServerStats(serverId, {
          totalTranslations: serverConfig.stats.totalTranslations + 1,
          totalTokens: serverConfig.stats.totalTokens + (translationResult.tokens?.total || 0)
        });
        
        // Log response time if it's available
        if (translationResult.responseTime) {
          const totalTime = Date.now() - messageProcessStart;
          console.log(`Translation completed in ${translationResult.responseTime}ms (total processing: ${totalTime}ms)`);
        }
        
        // Make sure the reply was sent
        await replyPromise;
      } catch (error) {
        console.error('Error processing translation:', error);
        
        // Use a more specific error message if possible
        let errorMessage = '❌ Failed to translate message. Please try again later.';
        
        if (error.message?.includes('rate limit')) {
          errorMessage = '❌ Rate limit exceeded. Please try again in a few moments.';
        } else if (error.message?.includes('API')) {
          errorMessage = '❌ Translation API error. Please try a different model.';
        }
        
        // Reply with error message - try webhook first, fallback to reply
        sendViaWebhook(message.channel, {
          content: `**Error**: ${errorMessage}`,
          username: 'Translation Error',
          avatarURL: 'https://i.imgur.com/JYAVksw.png'
        }).catch(e => {
          // Fallback to standard reply
          return message.reply({
            content: errorMessage,
            allowedMentions: { repliedUser: false }
          });
        }).catch(e => console.error('Could not send error message:', e));
      }
    }).catch(error => {
      console.error('Queue processing error:', error);
    });
  }
};

================
File: src/events/ready.js
================
// Event handler for when the bot is ready
import { ActivityType } from 'discord.js';

export default {
  name: 'ready',
  once: true,
  execute(client) {
    console.log(`Logged in as ${client.user.tag}!`);
    console.log(`Bot is ready in ${client.guilds.cache.size} servers!`);
    
    // Set bot activity using ActivityType from discord.js v14
    client.user.setActivity('!help | Translating...', { type: ActivityType.Playing });
    
    // Log active servers
    console.log('Connected servers:');
    client.guilds.cache.forEach(guild => {
      console.log(`- ${guild.name} (${guild.id})`);
    });
  }
};

================
File: src/index.js
================
import 'dotenv/config';
import { Client, GatewayIntentBits, Partials, Collection } from 'discord.js';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';
import { flushMemory } from './utils/translationMemory.js';
import { cleanupWebhooks } from './utils/webhookManager.js';

// Get the current file's directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Check if environment variables are set
if (!process.env.DISCORD_TOKEN) {
  console.error('ERROR: DISCORD_TOKEN is required in .env file');
  process.exit(1);
}

if (!process.env.OPENAI_API_KEY || !process.env.ANTHROPIC_API_KEY || !process.env.GOOGLE_API_KEY) {
  console.warn('WARNING: One or more API keys are missing. Some translation models may not work.');
}

// Initialize Discord client with required intents
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildMessageReactions
  ],
  partials: [
    Partials.Message,
    Partials.Channel,
    Partials.Reaction
  ]
});

// Store commands and active translation sessions
client.commands = new Collection();
client.activeSessions = new Map();

// Load commands
const commandsPath = path.join(__dirname, 'commands');
const commandFiles = fs.readdirSync(commandsPath).filter(file => file.endsWith('.js'));

console.log('Loading commands...');

for (const file of commandFiles) {
  const filePath = path.join(commandsPath, file);
  const commandModule = await import(`file://${filePath}`);
  const command = commandModule.default;
  
  if ('name' in command && 'execute' in command) {
    client.commands.set(command.name, command);
    console.log(`Loaded command: ${command.name}`);
  } else {
    console.warn(`Command at ${filePath} is missing required properties`);
  }
}

// Load events
const eventsPath = path.join(__dirname, 'events');
const eventFiles = fs.readdirSync(eventsPath).filter(file => file.endsWith('.js'));

console.log('Loading events...');

for (const file of eventFiles) {
  const filePath = path.join(eventsPath, file);
  const eventModule = await import(`file://${filePath}`);
  const event = eventModule.default;
  
  if (event.once) {
    client.once(event.name, (...args) => event.execute(...args, client));
  } else {
    client.on(event.name, (...args) => event.execute(...args, client));
  }
  
  console.log(`Loaded event: ${event.name}`);
}

// Handle process events for clean shutdown
process.on('SIGINT', () => {
  console.log('SIGINT received. Shutting down...');
  flushMemory(); // Flush translation memory to disk
  cleanupWebhooks(); // Clean up webhook connections
  client.destroy();
  process.exit(0);
});

process.on('SIGTERM', () => {
  console.log('SIGTERM received. Shutting down...');
  flushMemory(); // Flush translation memory to disk
  cleanupWebhooks(); // Clean up webhook connections
  client.destroy();
  process.exit(0);
});

// Also handle unhandled rejections and exceptions to ensure data is saved
process.on('unhandledRejection', (error) => {
  console.error('Unhandled promise rejection:', error);
  flushMemory();
  cleanupWebhooks();
});

process.on('uncaughtException', (error) => {
  console.error('Uncaught exception:', error);
  flushMemory();
  cleanupWebhooks();
  process.exit(1);
});

// Log in to Discord
console.log('Connecting to Discord...');
client.login(process.env.DISCORD_TOKEN)
  .then(() => {
    console.log('Bot is online!');
  })
  .catch(error => {
    console.error('Failed to connect to Discord:', error);
    process.exit(1);
  });

================
File: src/models/anthropicModel.js
================
import Anthropic from '@anthropic-ai/sdk';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the current file's directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Initialize Anthropic API
const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY
});

// Get system prompts from config
function getSystemPrompt(mode) {
  try {
    const configPath = path.join(__dirname, '../../config/default.json');
    const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    return config.systemPrompts[mode] || '';
  } catch (error) {
    console.error('Error loading system prompts:', error);
    return '';
  }
}

// Translate text using Anthropic Claude
async function anthropicTranslate(text, sourceLang, mode) {
  // Get the appropriate system prompt
  const systemPrompt = getSystemPrompt(mode);
  
  // Define target language based on source language and mode
  let targetLang;
  let userPrompt;
  
  if (mode === 'korean') {
    if (sourceLang === 'kor') {
      targetLang = 'eng'; // Korean to English
      userPrompt = `Translate the following Korean text to English: "${text}"`;
    } else if (sourceLang === 'eng') {
      targetLang = 'kor'; // English to Korean
      userPrompt = `Translate the following English text to Korean: "${text}"`;
    } else if (sourceLang === 'jpn') {
      targetLang = 'kor'; // Japanese to Korean
      userPrompt = `Translate the following Japanese text to Korean: "${text}"`;
    }
  } else { // japanese mode
    if (sourceLang === 'jpn') {
      targetLang = 'eng'; // Japanese to English
      userPrompt = `Translate the following Japanese text to English: "${text}"`;
    } else if (sourceLang === 'eng') {
      targetLang = 'jpn'; // English to Japanese
      userPrompt = `Translate the following English text to Japanese: "${text}"`;
    } else if (sourceLang === 'kor') {
      targetLang = 'jpn'; // Korean to Japanese
      userPrompt = `Translate the following Korean text to Japanese: "${text}"`;
    }
  }
  
  try {
    const response = await anthropic.messages.create({
      model: 'claude-3-7-sonnet-20250219',
      max_tokens: 1000,
      system: systemPrompt,
      messages: [
        {
          role: 'user',
          content: userPrompt
        }
      ]
    });
    
    const translation = response.content[0].text.trim();
    
    // Claude doesn't provide token counts in the same way as OpenAI,
    // so we'll estimate based on the length of the text
    const tokens = {
      prompt: Math.ceil(userPrompt.length / 4) + Math.ceil(systemPrompt.length / 4),
      completion: Math.ceil(translation.length / 4),
      total: Math.ceil((userPrompt.length + systemPrompt.length + translation.length) / 4)
    };
    
    return {
      translation,
      tokens
    };
  } catch (error) {
    console.error('Anthropic translation error:', error);
    throw new Error(`Anthropic translation failed: ${error.message}`);
  }
}

export { anthropicTranslate };

================
File: src/models/googleModel.js
================
import { GoogleGenerativeAI } from '@google/generative-ai';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the current file's directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Initialize Google Generative AI
const genAI = new GoogleGenerativeAI(process.env.GOOGLE_API_KEY);

// Get system prompts from config
function getSystemPrompt(mode) {
  try {
    const configPath = path.join(__dirname, '../../config/default.json');
    const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    return config.systemPrompts[mode] || '';
  } catch (error) {
    console.error('Error loading system prompts:', error);
    return '';
  }
}

// Translate text using Google Gemini
async function geminiTranslate(text, sourceLang, mode) {
  // Get the appropriate system prompt
  const systemPrompt = getSystemPrompt(mode);
  
  // Define target language based on source language and mode
  let targetLang;
  let userPrompt;
  
  if (mode === 'korean') {
    if (sourceLang === 'kor') {
      targetLang = 'eng'; // Korean to English
      userPrompt = `Translate the following Korean text to English: "${text}"`;
    } else if (sourceLang === 'eng') {
      targetLang = 'kor'; // English to Korean
      userPrompt = `Translate the following English text to Korean: "${text}"`;
    } else if (sourceLang === 'jpn') {
      targetLang = 'kor'; // Japanese to Korean
      userPrompt = `Translate the following Japanese text to Korean: "${text}"`;
    }
  } else { // japanese mode
    if (sourceLang === 'jpn') {
      targetLang = 'eng'; // Japanese to English
      userPrompt = `Translate the following Japanese text to English: "${text}"`;
    } else if (sourceLang === 'eng') {
      targetLang = 'jpn'; // English to Japanese
      userPrompt = `Translate the following English text to Japanese: "${text}"`;
    } else if (sourceLang === 'kor') {
      targetLang = 'jpn'; // Korean to Japanese
      userPrompt = `Translate the following Korean text to Japanese: "${text}"`;
    }
  }
  
  try {
    // Get the Gemini model
    const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });
    
    // Combine system prompt and user query
    const fullPrompt = `${systemPrompt}\n\n${userPrompt}`;
    
    // Generate content
    const result = await model.generateContent(fullPrompt);
    const translation = result.response.text().trim();
    
    // Gemini doesn't provide token counts, so we'll estimate based on the length of the text
    const tokens = {
      prompt: Math.ceil(fullPrompt.length / 4),
      completion: Math.ceil(translation.length / 4),
      total: Math.ceil((fullPrompt.length + translation.length) / 4)
    };
    
    return {
      translation,
      tokens
    };
  } catch (error) {
    console.error('Google Gemini translation error:', error);
    throw new Error(`Google Gemini translation failed: ${error.message}`);
  }
}

export { geminiTranslate };

================
File: src/models/openaiModel.js
================
import OpenAI from 'openai';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the current file's directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Initialize OpenAI API
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// Detect language using LLM instead of franc
async function detectLanguageWithLLM(text) {
  try {
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        {
          role: "system",
          content: "Analyze the text and determine the alphabet used. Respond with 'Korean' for 한글, 'Japanese' for 日本語, or 'English' for English or other languages."
        },
        {
          role: "user",
          content: text
        }
      ],
      temperature: 0,
      max_tokens: 10
    });
    
    const result = response.choices[0].message.content.trim().toLowerCase();
    
    if (result.includes('korean')) return 'kor';
    if (result.includes('japanese')) return 'jpn';
    return 'eng'; // Default to English for other cases
  } catch (error) {
    console.error('Language detection error:', error);
    return 'eng'; // Default to English on error
  }
}

// Get system prompts from config
function getSystemPrompt(mode) {
  try {
    const configPath = path.join(__dirname, '../../config/default.json');
    const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    return config.systemPrompts[mode] || '';
  } catch (error) {
    console.error('Error loading system prompts:', error);
    return '';
  }
}

// Translate text using OpenAI GPT-4o
async function openaiTranslate(text, sourceLang, mode) {
  // Get the appropriate system prompt
  const systemPrompt = getSystemPrompt(mode);
  
  // Define target language based on source language and mode
  let targetLang;
  let userPrompt;
  
  if (mode === 'korean') {
    if (sourceLang === 'kor') {
      targetLang = 'eng'; // Korean to English
      userPrompt = `Translate the following Korean text to English: "${text}"`;
    } else if (sourceLang === 'eng') {
      targetLang = 'kor'; // English to Korean
      userPrompt = `Translate the following English text to Korean: "${text}"`;
    } else if (sourceLang === 'jpn') {
      targetLang = 'kor'; // Japanese to Korean
      userPrompt = `Translate the following Japanese text to Korean: "${text}"`;
    }
  } else { // japanese mode
    if (sourceLang === 'jpn') {
      targetLang = 'eng'; // Japanese to English
      userPrompt = `Translate the following Japanese text to English: "${text}"`;
    } else if (sourceLang === 'eng') {
      targetLang = 'jpn'; // English to Japanese
      userPrompt = `Translate the following English text to Japanese: "${text}"`;
    } else if (sourceLang === 'kor') {
      targetLang = 'jpn'; // Korean to Japanese
      userPrompt = `Translate the following Korean text to Japanese: "${text}"`;
    }
  }
  
  try {
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        {
          role: 'system',
          content: systemPrompt
        },
        {
          role: 'user',
          content: userPrompt
        }
      ],
      temperature: 0.7,
      max_tokens: 1000
    });
    
    const translation = response.choices[0].message.content.trim();
    const tokens = {
      prompt: response.usage.prompt_tokens,
      completion: response.usage.completion_tokens,
      total: response.usage.total_tokens
    };
    
    return {
      translation,
      tokens
    };
  } catch (error) {
    console.error('OpenAI translation error:', error);
    throw new Error(`OpenAI translation failed: ${error.message}`);
  }
}

export { openaiTranslate, detectLanguageWithLLM };

================
File: src/services/translationService.js
================
import { openaiTranslate, detectLanguageWithLLM } from '../models/openaiModel.js';
import { anthropicTranslate } from '../models/anthropicModel.js';
import { geminiTranslate } from '../models/googleModel.js';
import { getTranslationMemory, saveTranslation } from '../utils/translationMemory.js';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the current file's directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Preprocess message content to remove irrelevant information
 * @param {string} content - Message content to preprocess
 * @returns {string} Cleaned message content
 */
// Cache preprocessing config to avoid disk reads
let cachedPreprocessingConfig = null;

// Load preprocessing config
function getPreprocessingConfig() {
  if (cachedPreprocessingConfig) return cachedPreprocessingConfig;
  
  try {
    const configPath = path.join(__dirname, '../../config/default.json');
    const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    cachedPreprocessingConfig = config.messagePreprocessing || {
      enabled: true,
      removeEmojis: true,
      removeTimestamps: true,
      removeUrls: true
    };
    return cachedPreprocessingConfig;
  } catch (error) {
    console.error('Error loading preprocessing config:', error);
    cachedPreprocessingConfig = {
      enabled: true,
      removeEmojis: true,
      removeTimestamps: true,
      removeUrls: true
    };
    return cachedPreprocessingConfig;
  }
}

function preprocessMessage(content) {
  // Skip preprocessing if content is too short
  if (!content || content.length < 10) return content;
  
  const preprocessConfig = getPreprocessingConfig();
  
  // Skip if preprocessing is disabled
  if (!preprocessConfig.enabled) return content;
  
  // Remove Discord emojis
  if (preprocessConfig.removeEmojis) {
    content = content.replace(/(:(\S+):)/g, '');
  }
  
  // Remove Discord timestamps
  if (preprocessConfig.removeTimestamps) {
    content = content.replace(/([^—]+) — (?:Today at|Yesterday at|\d{1,2}\/\d{1,2}\/\d{4}) \d{1,2}:\d{2} [AP]M/g, '$1:');
  }
  
  // Remove URLs
  if (preprocessConfig.removeUrls) {
    content = content.replace(/(https?:\/\/[^\s]+)/g, '');
  }
  
  // Remove excessive whitespace that might be left after filtering
  content = content.replace(/\n{3,}/g, '\n\n');
  content = content.trim();
  
  return content;
}

// Performance tracking
const perfMetrics = {
  totalTranslations: 0,
  cachedTranslations: 0,
  apiTranslations: 0,
  totalTime: 0,
  cacheLookupTime: 0,
  apiCallTime: 0
};

// Language codes mapping
const LANGUAGES = {
  eng: 'English',
  kor: 'Korean',
  jpn: 'Japanese'
};

// Flag emojis for each language
const FLAGS = {
  eng: '🇺🇸',
  kor: '🇰🇷',
  jpn: '🇯🇵'
};

// Cache emoji config to avoid disk reads on every translation
let cachedEmojis = null;

// Load emoji config
function getEmojis() {
  if (cachedEmojis) return cachedEmojis;
  
  try {
    const configPath = path.join(__dirname, '../../config/default.json');
    const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    cachedEmojis = config.emoji || {
      translating: '🔄',
      error: '❌',
      english: '🇺🇸',
      korean: '🇰🇷', 
      japanese: '🇯🇵'
    };
    return cachedEmojis;
  } catch (error) {
    console.error('Error loading emoji config:', error);
    cachedEmojis = {
      translating: '🔄',
      error: '❌',
      english: '🇺🇸',
      korean: '🇰🇷',
      japanese: '🇯🇵'
    };
    return cachedEmojis;
  }
}

// Detect language of text using LLM instead of franc
async function detectLanguage(text) {
  if (!text || text.trim().length < 3) {
    return 'eng'; // Default to English for very short texts
  }
  
  // Use LLM-based detection
  return await detectLanguageWithLLM(text);
}

// Always translate if the language is one of our supported languages
function shouldTranslate(detectedLang, mode) {
  // We always translate if language is Korean, Japanese, or English
  return detectedLang === 'kor' || detectedLang === 'jpn' || detectedLang === 'eng';
}

// Get target language based on source language and mode
function getTargetLanguage(sourceLang, mode) {
  if (mode === 'korean') {
    if (sourceLang === 'kor') return 'eng';
    if (sourceLang === 'eng') return 'kor';
    if (sourceLang === 'jpn') return 'kor';
  } else { // japanese mode
    if (sourceLang === 'jpn') return 'eng';
    if (sourceLang === 'eng') return 'jpn';
    if (sourceLang === 'kor') return 'jpn';
  }
  return 'eng'; // default
}

// Format translation result for display - Only show tokens for non-cached translations
function formatTranslation(result) {
  if (result.model === 'cache') {
    return `${result.translated}`;
  } else {
    return `${result.translated}\n📊 Tokens: ${result.tokens.total}`;
  }
}

// Translate a message
async function translateMessage(message, serverConfig) {
  const emojis = getEmojis();
  const startTime = Date.now();
  let detectedLang = 'eng';
  
  try {
  // Preprocess the message content to remove irrelevant information
  const content = preprocessMessage(message.content);
  
  // Skip empty messages or commands
  if (!content.trim() || content.startsWith(serverConfig.prefix || '!')) {
    return null;
  }
    
    // Detect language using LLM
    detectedLang = await detectLanguage(content);
    
    // Check if translation is needed based on mode
    if (!shouldTranslate(detectedLang, serverConfig.mode)) {
      return null;
    }
    
    // Performance tracking
    perfMetrics.totalTranslations++;
    const cacheStartTime = Date.now();
    
    // Check translation memory first
    const cachedTranslation = getTranslationMemory(content, serverConfig.mode);
    
    // Update cache lookup metrics
    perfMetrics.cacheLookupTime += (Date.now() - cacheStartTime);
    
    // If we have a cached translation, return it immediately without adding reactions
    if (cachedTranslation) {
      perfMetrics.cachedTranslations++;
      
      // Add language flag reaction for cached results - but don't wait for it
      message.react(FLAGS[detectedLang] || '❓').catch(e => 
        console.error('Could not add flag reaction to cached translation:', e)
      );
      
      return {
        original: content,
        translated: cachedTranslation.translation,
        sourceLang: detectedLang,
        targetLang: getTargetLanguage(detectedLang, serverConfig.mode),
        model: 'cache',
        tokens: cachedTranslation.tokens
      };
    }
    
    // Since it's not cached, add thinking reaction
    // Don't await this - let it happen in the background to speed up response
    const reactionPromise = message.react(emojis.translating);
    
    // API translation performance tracking
    const apiStartTime = Date.now();
    perfMetrics.apiTranslations++;
    
    // Get translation using selected model
    let result;
    switch (serverConfig.model) {
      case 'gpt4o':
        result = await openaiTranslate(content, detectedLang, serverConfig.mode);
        break;
      case 'claude':
        result = await anthropicTranslate(content, detectedLang, serverConfig.mode);
        break;
      case 'gemini':
        result = await geminiTranslate(content, detectedLang, serverConfig.mode);
        break;
      default:
        result = await openaiTranslate(content, detectedLang, serverConfig.mode);
    }
    
    // Update API call metrics
    perfMetrics.apiCallTime += (Date.now() - apiStartTime);
    
    // Make sure reaction was added before updating
    await reactionPromise;
    
    // Save to translation memory - don't wait for this
    saveTranslation(content, result.translation, serverConfig.mode, result.tokens);
    
    // Update/replace existing reactions with flag
    try {
      await message.reactions.cache.get(emojis.translating)?.remove();
    } catch (e) {
      console.error('Could not remove translating reaction:', e);
    }
    
    // Add language flag reaction - don't wait for it to complete
    message.react(FLAGS[detectedLang] || '❓').catch(e => 
      console.error('Could not add flag reaction:', e)
    );
    
    // Update total performance time
    const totalTime = Date.now() - startTime;
    perfMetrics.totalTime += totalTime;
    
    // Log performance metrics every 50 translations
    if (perfMetrics.totalTranslations % 50 === 0) {
      console.log(`Translation Performance Metrics:
        Total: ${perfMetrics.totalTranslations}, 
        Cached: ${perfMetrics.cachedTranslations} (${Math.round(perfMetrics.cachedTranslations/perfMetrics.totalTranslations*100)}%),
        Avg time: ${Math.round(perfMetrics.totalTime/perfMetrics.totalTranslations)}ms,
        Avg cache lookup: ${Math.round(perfMetrics.cacheLookupTime/perfMetrics.totalTranslations)}ms,
        Avg API call: ${Math.round(perfMetrics.apiCallTime/perfMetrics.apiTranslations)}ms
      `);
    }
    
    return {
      original: content,
      translated: result.translation,
      sourceLang: detectedLang,
      targetLang: getTargetLanguage(detectedLang, serverConfig.mode),
      model: serverConfig.model,
      tokens: result.tokens,
      responseTime: totalTime
    };
  } catch (error) {
    // Be more specific about where the error occurred
    let errorMessage = 'Translation error';
    
    if (error.message?.includes('API')) {
      errorMessage = `API error: ${error.message}`;
    } else if (error.message?.includes('rate limit')) {
      errorMessage = 'Rate limit exceeded';
    }
    
    console.error(`${errorMessage}:`, error);
    
    try {
      // Don't await these operations to prevent blocking
      message.reactions.removeAll().catch(e => console.error('Could not clear reactions:', e));
      message.react(emojis.error).catch(e => console.error('Could not add error reaction:', e));
    } catch (reactionError) {
      console.error('Error handling reactions:', reactionError);
    }
    
    return null;
  }
}

export { 
  translateMessage, 
  detectLanguage, 
  shouldTranslate,
  getTargetLanguage,
  formatTranslation,
  LANGUAGES, 
  FLAGS,
  perfMetrics
};

================
File: src/utils/serverConfig.js
================
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the current file's directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Path to the server configs directory
const SERVER_CONFIG_DIR = path.join(__dirname, '../../data/servers');

// Load default config
function getDefaultConfig() {
  try {
    const defaultConfigPath = path.join(__dirname, '../../config/default.json');
    const config = JSON.parse(fs.readFileSync(defaultConfigPath, 'utf8'));
    
    return {
      mode: config.defaultMode || 'korean',
      model: config.defaultModel || 'gpt4o',
      autoTranslate: config.autoTranslate !== undefined ? config.autoTranslate : true,
      stats: {
        totalTranslations: 0,
        totalTokens: 0,
        sessionsStarted: 0,
        lastUsed: new Date().toISOString()
      }
    };
  } catch (error) {
    console.error('Error loading default config:', error);
    
    // Fallback default config
    return {
      mode: 'korean',
      model: 'gpt4o',
      autoTranslate: true,
      stats: {
        totalTranslations: 0,
        totalTokens: 0,
        sessionsStarted: 0,
        lastUsed: new Date().toISOString()
      }
    };
  }
}

// Load server config
function loadServerConfig(serverId) {
  try {
    const serverConfigPath = path.join(SERVER_CONFIG_DIR, `${serverId}.json`);
    
    if (fs.existsSync(serverConfigPath)) {
      const data = fs.readFileSync(serverConfigPath, 'utf8');
      return JSON.parse(data);
    }
    
    // If no config exists, create one with default values
    const defaultConfig = getDefaultConfig();
    saveServerConfig(serverId, defaultConfig);
    return defaultConfig;
  } catch (error) {
    console.error(`Error loading config for server ${serverId}:`, error);
    return getDefaultConfig();
  }
}

// Save server config
function saveServerConfig(serverId, config) {
  try {
    fs.ensureDirSync(SERVER_CONFIG_DIR);
    const serverConfigPath = path.join(SERVER_CONFIG_DIR, `${serverId}.json`);
    fs.writeFileSync(serverConfigPath, JSON.stringify(config, null, 2), 'utf8');
    return true;
  } catch (error) {
    console.error(`Error saving config for server ${serverId}:`, error);
    return false;
  }
}

// Update server stats
function updateServerStats(serverId, stats) {
  try {
    const config = loadServerConfig(serverId);
    config.stats = { ...config.stats, ...stats, lastUsed: new Date().toISOString() };
    return saveServerConfig(serverId, config);
  } catch (error) {
    console.error(`Error updating stats for server ${serverId}:`, error);
    return false;
  }
}

export { loadServerConfig, saveServerConfig, updateServerStats, getDefaultConfig };

================
File: src/utils/translationMemory.js
================
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the current file's directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Path to the translation memory file
const TRANSLATION_MEMORY_PATH = path.join(__dirname, '../../data/translations.json');

// Write buffer configuration
const WRITE_DELAY = 30000; // 30 seconds between writes
const MAX_BUFFER_SIZE = 20; // Write after 20 new translations
let writeBuffer = new Set(); // Track modified keys
let writeTimer = null;
let needsWrite = false;
let isShuttingDown = false;

// In-memory cache of translations using Map for better performance
const translationMemory = new Map();

// Load translation memory from file
function loadTranslationMemory() {
  try {
    if (fs.existsSync(TRANSLATION_MEMORY_PATH)) {
      const data = fs.readFileSync(TRANSLATION_MEMORY_PATH, 'utf8');
      const memoryObject = JSON.parse(data);
      
      // Convert object to Map
      const memoryMap = new Map();
      for (const [key, value] of Object.entries(memoryObject)) {
        memoryMap.set(key, value);
      }
      
      // Clear and populate the translationMemory Map
      translationMemory.clear();
      for (const [key, value] of memoryMap.entries()) {
        translationMemory.set(key, value);
      }
      
      console.log(`Loaded ${translationMemory.size} entries into translation memory`);
      return translationMemory;
    }
    return translationMemory;
  } catch (error) {
    console.error('Error loading translation memory:', error);
    return translationMemory;
  }
}

// Schedule a delayed write to disk
function scheduleWrite() {
  if (isShuttingDown) {
    // Write immediately during shutdown
    saveTranslationMemoryToFile();
    return;
  }
  
  if (writeTimer === null) {
    writeTimer = setTimeout(() => {
      if (needsWrite) {
        saveTranslationMemoryToFile();
      }
      writeTimer = null;
    }, WRITE_DELAY);
  }
  
  // If buffer exceeds threshold, write immediately
  if (writeBuffer.size >= MAX_BUFFER_SIZE) {
    clearTimeout(writeTimer);
    writeTimer = null;
    saveTranslationMemoryToFile();
  }
}

// Save translation memory to file
function saveTranslationMemoryToFile() {
  try {
    writeBuffer.clear();
    needsWrite = false;
    
    // Convert Map to object for JSON serialization
    const memoryObject = {};
    for (const [key, value] of translationMemory.entries()) {
      memoryObject[key] = value;
    }
    
    fs.ensureDirSync(path.dirname(TRANSLATION_MEMORY_PATH));
    fs.writeFileSync(TRANSLATION_MEMORY_PATH, JSON.stringify(memoryObject, null, 2), 'utf8');
    console.log(`Saved ${translationMemory.size} entries to translation memory file`);
  } catch (error) {
    console.error('Error saving translation memory:', error);
  }
}

// Get a translation from memory
function getTranslationMemory(text, mode) {
  const key = `${text.toLowerCase()}_${mode}`;
  return translationMemory.get(key);
}

// Save a translation to memory
function saveTranslation(originalText, translatedText, mode, tokens) {
  const key = `${originalText.toLowerCase()}_${mode}`;
  
  // Update memory cache
  translationMemory.set(key, {
    translation: translatedText,
    tokens: tokens,
    timestamp: new Date().toISOString()
  });
  
  // Mark as needing to be written to disk
  writeBuffer.add(key);
  needsWrite = true;
  
  // Prune if over limit (500 entries)
  try {
    const configPath = path.join(__dirname, '../../config/default.json');
    const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    const limit = config.translationMemoryLimit || 500;
    
    if (translationMemory.size > limit) {
      // Convert to array to sort by timestamp
      const entries = Array.from(translationMemory.entries())
        .map(([k, v]) => ({ key: k, ...v }))
        .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
      
      // Remove oldest entries
      const toRemove = entries.slice(0, translationMemory.size - limit);
      for (const entry of toRemove) {
        translationMemory.delete(entry.key);
      }
    }
  } catch (error) {
    console.error('Error pruning translation memory:', error);
  }
  
  // Schedule a delayed write
  scheduleWrite();
  
  return translationMemory.get(key);
}

// Initialize by loading memory
loadTranslationMemory();

// Setup shutdown handler to ensure data is saved
function flushMemory() {
  isShuttingDown = true;
  if (needsWrite) {
    saveTranslationMemoryToFile();
  }
}

// Export flush method for clean shutdown

export { 
  getTranslationMemory, 
  saveTranslation, 
  loadTranslationMemory,
  flushMemory 
};

================
File: src/utils/webhookManager.js
================
import { WebhookClient } from 'discord.js';
import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';

// Get the current file's directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Store webhook clients to avoid recreating them
const webhookCache = new Map();

/**
 * Split content into chunks that fit within Discord's 2000 character limit
 * @param {string} content - Message content to split
 * @returns {string[]} Array of content chunks
 */
function splitMessageContent(content) {
  const chunks = [];
  const maxLength = 1950; // Leaving some buffer for safety
  
  // If content is already within limits, just return it as a single chunk
  if (!content || content.length <= maxLength) {
    return [content];
  }
  
  let currentChunk = '';
  let currentLength = 0;
  
  // Try to split on paragraph or sentence boundaries when possible
  const paragraphs = content.split('\n');
  
  for (const paragraph of paragraphs) {
    // If a single paragraph is too long, we need to split it by sentences
    if (paragraph.length > maxLength) {
      const sentences = paragraph.split(/(?<=[.!?])\s+/);
      
      for (const sentence of sentences) {
        // If a single sentence is too long, we'll need to split it arbitrarily
        if (sentence.length > maxLength) {
          let tempSentence = sentence;
          while (tempSentence.length > maxLength) {
            const chunk = tempSentence.substring(0, maxLength);
            chunks.push(chunk);
            tempSentence = tempSentence.substring(maxLength);
          }
          if (tempSentence.length > 0) {
            currentChunk = tempSentence;
            currentLength = tempSentence.length;
          }
        } else if (currentLength + sentence.length + 1 <= maxLength) {
          // Add to current chunk if it fits
          currentChunk += (currentChunk ? ' ' : '') + sentence;
          currentLength += sentence.length + (currentChunk ? 1 : 0);
        } else {
          // Start a new chunk if it doesn't fit
          chunks.push(currentChunk);
          currentChunk = sentence;
          currentLength = sentence.length;
        }
      }
    } else if (currentLength + paragraph.length + 1 <= maxLength) {
      // Add paragraph to current chunk if it fits
      currentChunk += (currentChunk ? '\n' : '') + paragraph;
      currentLength += paragraph.length + (currentChunk ? 1 : 0);
    } else {
      // Start a new chunk if paragraph doesn't fit
      chunks.push(currentChunk);
      currentChunk = paragraph;
      currentLength = paragraph.length;
    }
  }
  
  // Don't forget the last chunk
  if (currentChunk) {
    chunks.push(currentChunk);
  }
  
  // Add part indicators for multiple chunks
  if (chunks.length > 1) {
    return chunks.map((chunk, index) => 
      `[Part ${index + 1}/${chunks.length}] ${chunk}`
    );
  }
  
  return chunks;
}

/**
 * Get or create a webhook for a channel
 * @param {Object} channel - Discord channel object
 * @returns {Promise<WebhookClient>} Webhook client
 */
async function getOrCreateWebhook(channel) {
  // Check if we already have a webhook for this channel
  if (webhookCache.has(channel.id)) {
    return webhookCache.get(channel.id);
  }

  try {
    // Fetch existing webhooks
    const webhooks = await channel.fetchWebhooks();
    
    // Look for an existing translation webhook
    let webhook = webhooks.find(wh => wh.name === 'TranslationBot');
    
    // If no webhook exists, create one
    if (!webhook) {
      webhook = await channel.createWebhook({
        name: 'TranslationBot',
        avatar: 'https://i.imgur.com/OLCXZzb.png', // Default bot avatar - update with your own
        reason: 'Translation webhook for faster responses'
      });
      console.log(`Created new webhook in channel ${channel.name}`);
    }
    
    // Create a webhook client
    const webhookClient = new WebhookClient({ url: webhook.url });
    
    // Cache it for future use
    webhookCache.set(channel.id, webhookClient);
    
    return webhookClient;
  } catch (error) {
    console.error(`Error creating webhook for channel ${channel.id}:`, error);
    return null;
  }
}

/**
 * Send a message via webhook, splitting if necessary
 * @param {Object} channel - Discord channel object
 * @param {Object} options - Message options
 * @returns {Promise<Message|Message[]>} Sent message(s)
 */
async function sendViaWebhook(channel, options) {
  try {
    const webhook = await getOrCreateWebhook(channel);
    
    if (!webhook) {
      throw new Error('Could not get or create webhook');
    }
    
    // Split content if needed
    const contentChunks = splitMessageContent(options.content);
    const messages = [];
    
    // Send each chunk
    for (const chunkContent of contentChunks) {
      const message = await webhook.send({
        content: chunkContent,
        username: options.username || 'Translator',
        avatarURL: options.avatarURL,
        threadId: channel.isThread() ? channel.id : undefined
      });
      
      messages.push(message);
      
      // Small delay between chunks to avoid rate limiting
      if (contentChunks.length > 1 && contentChunks.indexOf(chunkContent) < contentChunks.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }
    
    return contentChunks.length === 1 ? messages[0] : messages;
  } catch (error) {
    console.error('Error sending webhook message:', error);
    
    // Fallback to regular channel send with splitting
    const contentChunks = splitMessageContent(options.content);
    const messages = [];
    
    for (const chunkContent of contentChunks) {
      const message = await channel.send(chunkContent);
      messages.push(message);
      
      // Small delay between chunks
      if (contentChunks.length > 1 && contentChunks.indexOf(chunkContent) < contentChunks.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }
    
    return contentChunks.length === 1 ? messages[0] : messages;
  }
}

/**
 * Clean up webhook connections
 */
function cleanupWebhooks() {
  for (const [channelId, webhook] of webhookCache.entries()) {
    webhook.destroy();
    console.log(`Destroyed webhook for channel ${channelId}`);
  }
  webhookCache.clear();
}

export { sendViaWebhook, cleanupWebhooks, splitMessageContent };

================
File: test-api-keys.js
================
// API Key validation script for Discord Translator Bot
import 'dotenv/config';
import OpenAI from 'openai';
import Anthropic from '@anthropic-ai/sdk';
import { GoogleGenerativeAI } from '@google/generative-ai';

console.log('==== Discord Translator Bot API Key Validation ====');

// OpenAI API key test
async function testOpenAI() {
  console.log('\nTesting OpenAI API key...');
  
  if (!process.env.OPENAI_API_KEY) {
    console.error('❌ OPENAI_API_KEY is not defined in .env file');
    return false;
  }
  
  try {
    const openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });
    
    console.log('Sending test request to OpenAI API...');
    const response = await openai.chat.completions.create({
      model: 'gpt-4o',
      messages: [
        { role: 'system', content: 'You are a helpful assistant.' },
        { role: 'user', content: 'Say "OpenAI API connection successful"' }
      ],
      max_tokens: 20
    });
    
    console.log('✅ OpenAI API response received:');
    console.log(`"${response.choices[0].message.content}"`);
    return true;
  } catch (error) {
    console.error('❌ OpenAI API Error:', error.message);
    if (error.response) {
      console.error('Status:', error.response.status);
      console.error('Data:', error.response.data);
    }
    return false;
  }
}

// Anthropic API key test
async function testAnthropic() {
  console.log('\nTesting Anthropic API key...');
  
  if (!process.env.ANTHROPIC_API_KEY) {
    console.error('❌ ANTHROPIC_API_KEY is not defined in .env file');
    return false;
  }
  
  try {
    const anthropic = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY
    });
    
    console.log('Sending test request to Anthropic API...');
    const response = await anthropic.messages.create({
      model: 'claude-3-opus-20240229',
      max_tokens: 20,
      system: 'You are a helpful assistant.',
      messages: [
        { role: 'user', content: 'Say "Anthropic API connection successful"' }
      ]
    });
    
    console.log('✅ Anthropic API response received:');
    console.log(`"${response.content[0].text}"`);
    return true;
  } catch (error) {
    console.error('❌ Anthropic API Error:', error.message);
    if (error.response) {
      console.error('Status:', error.response.status);
      console.error('Data:', error.response.data);
    }
    return false;
  }
}

// Google API key test
async function testGoogle() {
  console.log('\nTesting Google API key...');
  
  if (!process.env.GOOGLE_API_KEY) {
    console.error('❌ GOOGLE_API_KEY is not defined in .env file');
    return false;
  }
  
  try {
    const genAI = new GoogleGenerativeAI(process.env.GOOGLE_API_KEY);
    const model = genAI.getGenerativeModel({ model: 'gemini-pro' });
    
    console.log('Sending test request to Google Gemini API...');
    const result = await model.generateContent('Say "Google Gemini API connection successful"');
    const response = result.response;
    
    console.log('✅ Google Gemini API response received:');
    console.log(`"${response.text()}"`);
    return true;
  } catch (error) {
    console.error('❌ Google Gemini API Error:', error.message);
    if (error.response) {
      console.error('Status:', error.response.status);
      console.error('Data:', error.response.data);
    }
    return false;
  }
}

// Run all tests
async function runAllTests() {
  console.log('Starting API validation tests...\n');
  
  const openaiResult = await testOpenAI();
  const anthropicResult = await testAnthropic();
  const googleResult = await testGoogle();
  
  console.log('\n==== Test Results Summary ====');
  console.log(`OpenAI API: ${openaiResult ? '✅ Working' : '❌ Failed'}`);
  console.log(`Anthropic API: ${anthropicResult ? '✅ Working' : '❌ Failed'}`);
  console.log(`Google Gemini API: ${googleResult ? '✅ Working' : '❌ Failed'}`);
  
  if (!openaiResult && !anthropicResult && !googleResult) {
    console.log('\n❌ All API tests failed. Please check your API keys and internet connection.');
  } else if (openaiResult && anthropicResult && googleResult) {
    console.log('\n✅ All API tests passed! Your keys are valid.');
  } else {
    console.log('\n⚠️ Some API tests failed. Please update the failing API keys in your .env file.');
  }
}

// Execute all tests
runAllTests().catch(error => {
  console.error('Fatal error during testing:', error);
});

================
File: test-llm-detection.js
================
// Test script for LLM-based language detection
import 'dotenv/config';
import { detectLanguageWithLLM } from './src/models/openaiModel.js';

// Sample texts to test in different languages
const testSamples = [
  // Korean samples
  { text: '안녕하세요! 오늘 날씨가 좋네요.', expected: 'kor', description: 'Simple Korean greeting' },
  { text: '한국어로 대화하는 것이 재미있어요.', expected: 'kor', description: 'Korean sentence' },
  
  // Japanese samples
  { text: 'こんにちは！今日の天気はいいですね。', expected: 'jpn', description: 'Simple Japanese greeting' },
  { text: '日本語で話すのは楽しいです。', expected: 'jpn', description: 'Japanese sentence' },
  
  // English samples
  { text: 'Hello! The weather is nice today.', expected: 'eng', description: 'Simple English greeting' },
  { text: 'It\'s fun to chat in English.', expected: 'eng', description: 'English sentence' },
  
  // Mixed language samples
  { text: 'Hello 안녕하세요 こんにちは', expected: 'eng', description: 'Mixed greetings' },
  { text: 'I want to learn 한국어 and 日本語', expected: 'eng', description: 'English with Korean and Japanese words' },
  { text: '오늘 weather is 晴れ', expected: 'kor', description: 'Korean with English and Japanese words' },
  
  // Short texts
  { text: 'hi', expected: 'eng', description: 'Very short English' },
  { text: '안녕', expected: 'kor', description: 'Very short Korean' },
  { text: 'こん', expected: 'jpn', description: 'Very short Japanese' },
  
  // Edge cases
  { text: '1234567890', expected: 'eng', description: 'Numbers only' },
  { text: '😊👍🎉', expected: 'eng', description: 'Emojis only' },
  { text: 'lol', expected: 'eng', description: 'Short internet slang' },
  { text: 'ㅋㅋㅋㅋ', expected: 'kor', description: 'Korean internet slang' },
  { text: 'www', expected: 'eng', description: 'Japanese internet slang (might be detected as eng)' }
];

// Run tests
async function runTests() {
  console.log('=== Testing LLM-based Language Detection ===\n');
  
  let passed = 0;
  let failed = 0;
  
  for (const sample of testSamples) {
    try {
      console.log(`Testing: "${sample.text}" (${sample.description})`);
      console.log(`Expected: ${sample.expected}`);
      
      const result = await detectLanguageWithLLM(sample.text);
      
      console.log(`Detected: ${result}`);
      
      if (result === sample.expected) {
        console.log('✅ PASSED\n');
        passed++;
      } else {
        console.log('❌ FAILED\n');
        failed++;
      }
    } catch (error) {
      console.error(`Error testing "${sample.text}": ${error.message}`);
      console.log('❌ FAILED (error)\n');
      failed++;
    }
  }
  
  // Print summary
  console.log('=== Test Summary ===');
  console.log(`Total tests: ${testSamples.length}`);
  console.log(`Passed: ${passed}`);
  console.log(`Failed: ${failed}`);
  console.log(`Success rate: ${(passed / testSamples.length * 100).toFixed(2)}%`);
  
  if (failed === 0) {
    console.log('\n✅ All tests passed! LLM-based language detection is working correctly.');
  } else {
    console.log('\n⚠️ Some tests failed. Review the results to determine if adjustments are needed.');
  }
}

// Run all tests
runTests().catch(error => {
  console.error('Error during testing:', error);
});

================
File: test.js
================
import 'dotenv/config';
import { Client, GatewayIntentBits, ActivityType } from 'discord.js';

// Check environment variable
console.log('DISCORD_TOKEN defined:', !!process.env.DISCORD_TOKEN);

// Initialize a client but don't connect
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.MessageContent,
    GatewayIntentBits.GuildMessageReactions
  ]
});

// Simple event handler
client.once('ready', () => {
  console.log(`Logged in as ${client.user.tag}`);
  
  // Test activity setting
  try {
    client.user.setActivity('Testing...', { type: ActivityType.Playing });
    console.log('Activity set successfully');
  } catch (error) {
    console.error('Error setting activity:', error);
  }
  
  // Cleanup and exit
  setTimeout(() => {
    console.log('Test complete, exiting');
    client.destroy();
    process.exit(0);
  }, 2000);
});

// Log any errors
client.on('error', error => {
  console.error('Client error:', error);
});

// Attempt to connect
console.log('Attempting to connect to Discord...');
console.log('(NOTE: This will fail with placeholder token values)');

// Only attempt login if token seems valid
if (process.env.DISCORD_TOKEN && 
    process.env.DISCORD_TOKEN.length > 20 && 
    process.env.DISCORD_TOKEN !== 'your_discord_bot_token_here') {
  client.login(process.env.DISCORD_TOKEN)
    .then(() => console.log('Login successful'))
    .catch(error => {
      console.error('Login failed:', error.message);
      process.exit(1);
    });
} else {
  console.log('Not attempting login - please set a valid DISCORD_TOKEN in .env');
  
  // Test imports
  console.log('Testing imports...');
  Promise.all([
    import('franc').then(() => console.log('✓ franc imported successfully')),
    import('fs-extra').then(() => console.log('✓ fs-extra imported successfully')),
    import('path').then(() => console.log('✓ path imported successfully')),
    import('./src/utils/translationMemory.js')
      .then(() => console.log('✓ translationMemory.js imported successfully'))
      .catch(e => console.error('× translationMemory.js import failed:', e.message))
  ]).catch(e => console.error('Import test failed:', e));
}

================
File: TROUBLESHOOTING.md
================
# Discord Translator Bot Troubleshooting Guide

If your Discord translator bot is not responding to messages after starting a session, follow this guide to diagnose and fix the issue.

## Quick Diagnostic Scripts

I've created several diagnostic scripts to help you identify the problem:

### 1. Run the Debug Version

The debug version adds detailed logging to help track exactly what's happening:

```bash
node debug.js
```

This will show you:
- If messages are being received
- If the active session is being detected
- If language detection works
- Detailed errors from the translation process

### 2. Check API Keys

If the bot connects but doesn't translate, your API keys might be invalid:

```bash
npm install @anthropic-ai/sdk @google/generative-ai
node test-api-keys.js
```

This script tests connections to:
- OpenAI API
- Anthropic API
- Google Gemini API

### 3. Verify Data Structure

Make sure all required directories and files exist:

```bash
node check-data-structure.js
```

## Common Issues & Solutions

### Bot Connects But Doesn't Respond to Messages

1. **Check if session started correctly**
   - Look for confirmation message after running `!start`
   - Debug logs will show if `client.activeSessions` includes your channel

2. **API Key Problems**
   - Run `node test-api-keys.js` to check API key validity
   - Check for expired or rate-limited API keys

3. **Language Detection Issues**
   - The bot only translates Korean, English, and Japanese
   - Very short messages may not be detected correctly
   - Debug logs will show detected language and translation decision

4. **Directory Structure Problems**
   - Run `node check-data-structure.js` to verify and fix directories
   - Ensure the bot can create/read server config files

5. **Discord Permissions**
   - Ensure the bot has these permissions:
     - Read Messages/View Channels
     - Send Messages
     - Read Message History
     - Add Reactions

## Step-by-Step Troubleshooting Process

1. Start with the debug version:
   ```bash
   node debug.js
   ```

2. In your Discord server:
   - Run `!start` to begin a session
   - Check debug logs to confirm the session was created
   - Send a test message in Korean or English
   - Check debug logs for the message processing flow

3. If no translation happens:
   - Check if `Channel has active session: false` appears in logs
     - If so, the session isn't being saved properly
   - Check if language detection works 
     - Look for `Language detection: "your message..." => eng` or `kor`
   - Check if translation condition passes
     - Look for `Should translate check: Lang=eng, Mode=korean => true`

4. Verify API keys are working:
   ```bash
   node test-api-keys.js
   ```

5. Check data directories:
   ```bash
   node check-data-structure.js
   ```

## Still Having Issues?

If you've followed all steps and the bot still doesn't work:

1. Check your Discord bot token - it might need to be refreshed
2. Try regenerating API keys for OpenAI, Anthropic, and Google
3. Look for any rate limiting or quota issues in the API service dashboards
4. Clear any existing server configuration files in the `data/servers` directory



================================================================
End of Codebase
================================================================
